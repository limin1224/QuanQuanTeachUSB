C51 COMPILER V7.06   USBCORE                                                               02/25/2012 23:06:11 PAGE 1   


C51 COMPILER V7.06, COMPILATION OF MODULE USBCORE
OBJECT MODULE PLACED IN UsbCore.OBJ
COMPILER INVOKED BY: d:\Keil\C51\BIN\C51.EXE UsbCore.c BROWSE DEBUG OBJECTEXTEND TABS(1)

stmt level    source

   1          /******************************************************************
   2             本程序只供学习使用，未经作者许可，不得用于其它任何用途
   3             
   4                  欢迎访问我的USB专区：http://group.ednchina.com/93/
   5                  欢迎访问我的blog：   http://www.ednchina.com/blog/computer00
   6                                       http://computer00.21ic.org
   7          
   8                  感谢PCB赞助商――电子园： http://bbs.cepark.com/
   9          
  10          UsbCore.c file
  11          
  12          作者：电脑圈圈
  13          建立日期: 2008.06.29
  14          修改日期: 2012.01.24
  15          版本：V1.1
  16          版权所有，盗版必究。
  17          Copyright(C) 电脑圈圈 2008-2018
  18          All rights reserved            
  19          *******************************************************************/
  20          
  21          #include "config.h"
  22          #include "pdiusbd12.h"
  23          #include "uart.h"
  24          #include "usbcore.h"
  25          
  26          idata uint8 Buffer[16];  //读端点0用的缓冲区
  27          
  28          //USB设备请求的各字段
  29          uint8  bmRequestType;
  30          uint8  bRequest;
  31          uint16 wValue;
  32          uint16 wIndex;
  33          uint16 wLength;
  34          //当前发送数据的位置
  35          uint8 * pSendData;
  36          //需要发送数据的长度
  37          uint16 SendLength;
  38          //是否需要发送0数据包的标志。在USB控制传输的数据过程中，
  39          //当返回的数据包字节数少于最大包长时，会认为数据过程结束。
  40          //当请求的字节数比实际需要返回的字节数长，而实际返回的字节
  41          //数又刚好是端点0大小的整数倍时，就需要返回一个0长度的数据包
  42          //来结束数据过程。因此这里增加一个标志，供程序决定是否需要返回
  43          //一个0长度的数据包。
  44          uint8 NeedZeroPacket;
  45          
  46          //当前的配置值。只有在设置非0配置后
  47          uint8 ConfigValue;
  48          
  49          //端点1缓冲是否忙的标志。当缓冲区中有数据时，该标志为真。
  50          //当缓冲区中空闲时，该标志为假。
  51          uint8 Ep1InIsBusy;
  52          
  53          //USB设备描述符的定义
  54          code uint8 DeviceDescriptor[0x12]=  //设备描述符为18字节
  55          {
C51 COMPILER V7.06   USBCORE                                                               02/25/2012 23:06:11 PAGE 2   

  56          //bLength字段。设备描述符的长度为18(0x12)字节
  57           0x12,
  58           
  59          //bDescriptorType字段。设备描述符的编号为0x01
  60           0x01,
  61           
  62          //bcdUSB字段。这里设置版本为USB1.1，即0x0110。
  63          //由于是小端结构，所以低字节在先，即0x10，0x01。
  64           0x10,
  65           0x01,
  66           
  67          //bDeviceClass字段。我们不在设备描述符中定义设备类，
  68          //而在接口描述符中定义设备类，所以该字段的值为0。
  69           0x00,
  70           
  71          //bDeviceSubClass字段。bDeviceClass字段为0时，该字段也为0。
  72           0x00,
  73           
  74          //bDeviceProtocol字段。bDeviceClass字段为0时，该字段也为0。
  75           0x00,
  76           
  77          //bMaxPacketSize0字段。PDIUSBD12的端点0大小的16字节。
  78           0x10,
  79           
  80          //idVender字段。厂商ID号，我们这里取0x8888，仅供实验用。
  81          //实际产品不能随便使用厂商ID号，必须跟USB协会申请厂商ID号。
  82          //注意小端模式，低字节在先。
  83           0x88,
  84           0x88,
  85           
  86          //idProduct字段。产品ID号，由于是第二版的第一个实验，我们这里取0x0101。
  87          //注意小端模式，低字节应该在前。
  88           0x01,
  89           0x01,
  90           
  91          //bcdDevice字段。我们这个USB触摸屏刚开始做，就叫它1.0版吧，即0x0100。
  92          //小端模式，低字节在先。
  93           0x00,
  94           0x01,
  95           
  96          //iManufacturer字段。厂商字符串的索引值，为了方便记忆和管理，
  97          //字符串索引就从1开始吧。
  98           0x01,
  99          
 100          //iProduct字段。产品字符串的索引值。刚刚用了1，这里就取2吧。
 101          //注意字符串索引值不要使用相同的值。
 102           0x02,
 103           
 104          //iSerialNumber字段。设备的序列号字符串索引值。
 105          //这里取3就可以了。
 106           0x03,
 107          
 108          //bNumConfigurations字段。该设备所具有的配置数。
 109          //我们只需要一种配置就行了，因此该值设置为1。
 110           0x01
 111          };
 112          //////////////////////////设备描述符完毕//////////////////////////////
 113          
 114          //USB报告描述符的定义
 115          code uint8 ReportDescriptor[]=
 116          {
 117           //每行开始的第一字节为该条目的前缀，前缀的格式为：
C51 COMPILER V7.06   USBCORE                                                               02/25/2012 23:06:11 PAGE 3   

 118           //D7~D4：bTag。D3~D2：bType；D1~D0：bSize。以下分别对每个条目注释。
 119           
 120           //这是一个全局（bType为1）条目，选择用途页为普通桌面Generic Desktop Page(0x01)
 121           //后面跟一字节数据（bSize为1），后面的字节数就不注释了，
 122           //自己根据bSize来判断。
 123           0x05, 0x01, // USAGE_PAGE (Generic Desktop)
 124           
 125           //这是一个局部（bType为2）条目，说明接下来的应用集合用途用于鼠标
 126           0x09, 0x02, // USAGE (Mouse)
 127           
 128           //这是一个主（bType为0）条目，开集合，后面跟的数据0x01表示
 129           //该集合是一个应用集合。它的性质在前面由用途页和用途定义为
 130           //普通桌面用的鼠标。
 131           0xa1, 0x01, // COLLECTION (Application)
 132           
 133           //这是一个局部条目。说明用途为指针集合
 134           0x09, 0x01, //   USAGE (Pointer)
 135           
 136           //这是一个主条目，开集合，后面跟的数据0x00表示该集合是一个
 137           //物理集合，用途由前面的局部条目定义为指针集合。
 138           0xa1, 0x00, //   COLLECTION (Physical)
 139           
 140           //这是一个全局条目，选择用途页为按键（Button Page(0x09)）
 141           0x05, 0x09, //     USAGE_PAGE (Button)
 142           
 143           //这是一个局部条目，说明用途的最小值为1。实际上是鼠标左键。
 144           0x19, 0x01, //     USAGE_MINIMUM (Button 1)
 145           
 146           //这是一个局部条目，说明用途的最大值为3。实际上是鼠标中键。
 147           0x29, 0x03, //     USAGE_MAXIMUM (Button 3)
 148           
 149           //这是一个全局条目，说明返回的数据的逻辑值（就是我们返回的数据域的值啦）
 150           //最小为0。因为我们这里用Bit来表示一个数据域，因此最小为0，最大为1。
 151           0x15, 0x00, //     LOGICAL_MINIMUM (0)
 152           
 153           //这是一个全局条目，说明逻辑值最大为1。
 154           0x25, 0x01, //     LOGICAL_MAXIMUM (1)
 155           
 156           //这是一个全局条目，说明数据域的数量为三个。
 157           0x95, 0x03, //     REPORT_COUNT (3)
 158           
 159           //这是一个全局条目，说明每个数据域的长度为1个bit。
 160           0x75, 0x01, //     REPORT_SIZE (1)
 161           
 162           //这是一个主条目，说明有3个长度为1bit的数据域（数量和长度
 163           //由前面的两个全局条目所定义）用来做为输入，
 164           //属性为：Data,Var,Abs。Data表示这些数据可以变动，Var表示
 165           //这些数据域是独立的，每个域表示一个意思。Abs表示绝对值。
 166           //这样定义的结果就是，第一个数据域bit0表示按键1（左键）是否按下，
 167           //第二个数据域bit1表示按键2（右键）是否按下，第三个数据域bit2表示
 168           //按键3（中键）是否按下。
 169           0x81, 0x02, //     INPUT (Data,Var,Abs)
 170           
 171           //这是一个全局条目，说明数据域数量为1个
 172           0x95, 0x01, //     REPORT_COUNT (1)
 173           
 174           //这是一个全局条目，说明每个数据域的长度为5bit。
 175           0x75, 0x05, //     REPORT_SIZE (5)
 176           
 177           //这是一个主条目，输入用，由前面两个全局条目可知，长度为5bit，
 178           //数量为1个。它的属性为常量（即返回的数据一直是0）。
 179           //这个只是为了凑齐一个字节（前面用了3个bit）而填充的一些数据
C51 COMPILER V7.06   USBCORE                                                               02/25/2012 23:06:11 PAGE 4   

 180           //而已，所以它是没有实际用途的。
 181           0x81, 0x03, //     INPUT (Cnst,Var,Abs)
 182            
 183           //这是一个全局条目，选择用途页为普通桌面Generic Desktop Page(0x01)
 184           0x05, 0x01, //     USAGE_PAGE (Generic Desktop)
 185           
 186           //这是一个局部条目，说明用途为X轴
 187           0x09, 0x30, //     USAGE (X)
 188           
 189           //这是一个局部条目，说明用途为Y轴
 190           0x09, 0x31, //     USAGE (Y)
 191          
 192           //下面两个为全局条目，说明返回的逻辑最小和最大值。
 193           //这里定义X和Y轴的逻辑最小值为0，即坐标原点
 194           //X和Y轴的逻辑最大值为4096，即屏幕右下方的坐标为（4096，4096）。
 195           //由于4096超过了一字节的范围，所以需要用2字节的格式表示最大值
 196           0x15, 0x00, //     LOGICAL_MINIMUM (0)
 197           0x26, 0x00, 0x10, //     LOGICAL_MAXIMUM (4096)
 198          
 199           //下面两个为全局条目，说明返回的物理最小和最大值。
 200           //这里定义X和Y轴的物理最小值为0，即坐标原点
 201           //X和Y轴的物理最大值为4096，即屏幕右下方的坐标为（4096，4096）。
 202           //由于4096超过了一字节的范围，所以需要用2字节的格式表示最大值
 203           0x35, 0x00,    //Physical Minimum (0)
 204           0x46, 0x00, 0x10, //Physical Maximum(4096)
 205          
 206           //这是一个全局条目，说明数据域的长度为16bit。
 207           0x75, 0x10, //     REPORT_SIZE (16)
 208           
 209           //这是一个全局条目，说明数据域的个数为2个。
 210           0x95, 0x02, //     REPORT_COUNT (2)
 211           
 212           //这是一个主条目。它说明这两个16bit的数据域是输入用的，
 213           //属性为：Data,Var,Abs。Data说明数据是可以变的，Var说明
 214           //这些数据域是独立的，Abs表示这些值是绝对值。
 215           0x81, 0x02, //     INPUT (Data,Var,Abs)
 216           
 217           //下面这两个主条目用来关闭前面的集合用。
 218           //我们开了两个集合，所以要关两次。bSize为0，所以后面没数据。
 219           0xc0,       //   END_COLLECTION
 220           0xc0        // END_COLLECTION
 221          };
 222          //通过上面的报告描述符的定义，我们知道返回的输入报告具有5字节。
 223          //第一字节的低3位用来表示按键是否按下的，高5位为常数0，无用。
 224          //第二、三字节表示X轴的绝对坐标，第四、五字节表示Y轴的绝对坐标，
 225          //我们要按照上面的格式将实际的触摸屏数据通过中断端点1返回给电脑。
 226          ///////////////////////////报告描述符完毕////////////////////////////
 227          
 228          //USB配置描述符集合的定义
 229          //配置描述符总长度为9+9+9+7字节
 230          code uint8 ConfigurationDescriptor[9+9+9+7]=
 231          {
 232           /***************配置描述符***********************/
 233           //bLength字段。配置描述符的长度为9字节。
 234           0x09,
 235           
 236           //bDescriptorType字段。配置描述符编号为0x02。
 237           0x02,
 238           
 239           //wTotalLength字段。配置描述符集合的总长度，
 240           //包括配置描述符本身、接口描述符、类描述符、端点描述符等。
 241           sizeof(ConfigurationDescriptor)&0xFF, //低字节
C51 COMPILER V7.06   USBCORE                                                               02/25/2012 23:06:11 PAGE 5   

 242           (sizeof(ConfigurationDescriptor)>>8)&0xFF, //高字节
 243           
 244           //bNumInterfaces字段。该配置包含的接口数，只有一个接口。
 245           0x01,
 246           
 247           //bConfiguration字段。该配置的值为1。
 248           0x01,
 249           
 250           //iConfigurationz字段，该配置的字符串索引。这里没有，为0。
 251           0x00,
 252           
 253           //bmAttributes字段，该设备的属性。由于我们的板子是总线供电的，
 254           //并且我们不想实现远程唤醒的功能，所以该字段的值为0x80。
 255           0x80,
 256           
 257           //bMaxPower字段，该设备需要的最大电流量。由于我们的板子
 258           //需要的电流不到100mA，因此我们这里设置为100mA。由于每单位
 259           //电流为2mA，所以这里设置为50(0x32)。
 260           0x32,
 261           
 262           /*******************接口描述符*********************/
 263           //bLength字段。接口描述符的长度为9字节。
 264           0x09,
 265           
 266           //bDescriptorType字段。接口描述符的编号为0x04。
 267           0x04,
 268           
 269           //bInterfaceNumber字段。该接口的编号，第一个接口，编号为0。
 270           0x00,
 271           
 272           //bAlternateSetting字段。该接口的备用编号，为0。
 273           0x00,
 274           
 275           //bNumEndpoints字段。非0端点的数目。由于USB触摸屏只需要一个
 276           //中断输入端点，因此该值为1。
 277           0x01,
 278           
 279           //bInterfaceClass字段。该接口所使用的类。USB触摸屏是HID类，
 280           //HID类的编码为0x03。
 281           0x03,
 282           
 283           //bInterfaceSubClass字段。该接口所使用的子类。在HID1.1协议中，
 284           //只规定了一种子类：支持BIOS引导启动的子类。
 285           //USB键盘、鼠标属于该子类，子类代码为0x01。
 286           0x00,
 287           
 288           //bInterfaceProtocol字段。如果子类为支持引导启动的子类，
 289           //则协议可选择鼠标和键盘。键盘代码为0x01，鼠标代码为0x02。
 290           0x00,
 291           
 292           //iConfiguration字段。该接口的字符串索引值。这里没有，为0。
 293           0x00,
 294           
 295           /******************HID描述符************************/
 296           //bLength字段。本HID描述符下只有一个下级描述符。所以长度为9字节。
 297           0x09,
 298           
 299           //bDescriptorType字段。HID描述符的编号为0x21。
 300           0x21,
 301           
 302           //bcdHID字段。本协议使用的HID1.1协议。注意低字节在先。
 303           0x10,
C51 COMPILER V7.06   USBCORE                                                               02/25/2012 23:06:11 PAGE 6   

 304           0x01,
 305           
 306           //bCountyCode字段。设备适用的国家代码，这里选择为美国，代码0x21。
 307           0x21,
 308           
 309           //bNumDescriptors字段。下级描述符的数目。我们只有一个报告描述符。
 310           0x01,
 311           
 312           //bDescritporType字段。下级描述符的类型，为报告描述符，编号为0x22。
 313           0x22,
 314           
 315           //bDescriptorLength字段。下级描述符的长度。下级描述符为报告描述符。
 316           sizeof(ReportDescriptor)&0xFF,
 317           (sizeof(ReportDescriptor)>>8)&0xFF,
 318           
 319           /**********************端点描述符***********************/
 320           //bLength字段。端点描述符长度为7字节。
 321           0x07,
 322           
 323           //bDescriptorType字段。端点描述符编号为0x05。
 324           0x05,
 325           
 326           //bEndpointAddress字段。端点的地址。我们使用D12的输入端点1。
 327           //D7位表示数据方向，输入端点D7为1。所以输入端点1的地址为0x81。
 328           0x81,
 329           
 330           //bmAttributes字段。D1~D0为端点传输类型选择。
 331           //该端点为中断端点。中断端点的编号为3。其它位保留为0。
 332           0x03,
 333           
 334           //wMaxPacketSize字段。该端点的最大包长。端点1的最大包长为16字节。
 335           //注意低字节在先。
 336           0x10,
 337           0x00,
 338           
 339           //bInterval字段。端点查询的时间，我们设置为10个帧时间，即10ms。
 340           0x0a
 341          };
 342          ////////////////////////配置描述符集合完毕//////////////////////////
 343          
 344          /************************语言ID的定义********************/
 345          code uint8 LanguageId[4]=
 346          {
 347           0x04, //本描述符的长度
 348           0x03, //字符串描述符
 349           //0x0409为美式英语的ID
 350           0x09,
 351           0x04
 352          };
 353          ////////////////////////语言ID完毕//////////////////////////////////
 354          
 355          /**************************************************/
 356          /*********        本转换结果来自         **********/
 357          /********* Http://computer00.21ic.org    **********/
 358          /*********        作者: 电脑圈圈         **********/
 359          /*********         欢迎大家使用          **********/
 360          /*********    版权所有，盗版请写明出处   **********/
 361          /**************************************************/
 362          
 363          //http://computer00.21ic.org/user1/2198/archives/2007/42769.html
 364          //字符串“电脑圈圈的USB专区 Http://group.ednchina.com/93/”的Unicode编码
 365          //8位小端格式
C51 COMPILER V7.06   USBCORE                                                               02/25/2012 23:06:11 PAGE 7   

 366          code uint8 ManufacturerStringDescriptor[82]={
 367          82,         //该描述符的长度为82字节
 368          0x03,       //字符串描述符的类型编码为0x03
 369          0x35, 0x75, //电
 370          0x11, 0x81, //脑
 371          0x08, 0x57, //圈
 372          0x08, 0x57, //圈
 373          0x84, 0x76, //的
 374          0x55, 0x00, //U
 375          0x53, 0x00, //S
 376          0x42, 0x00, //B
 377          0x13, 0x4e, //专
 378          0x3a, 0x53, //区
 379          0x20, 0x00, // 
 380          0x48, 0x00, //H
 381          0x74, 0x00, //t
 382          0x74, 0x00, //t
 383          0x70, 0x00, //p
 384          0x3a, 0x00, //:
 385          0x2f, 0x00, ///
 386          0x2f, 0x00, ///
 387          0x67, 0x00, //g
 388          0x72, 0x00, //r
 389          0x6f, 0x00, //o
 390          0x75, 0x00, //u
 391          0x70, 0x00, //p
 392          0x2e, 0x00, //.
 393          0x65, 0x00, //e
 394          0x64, 0x00, //d
 395          0x6e, 0x00, //n
 396          0x63, 0x00, //c
 397          0x68, 0x00, //h
 398          0x69, 0x00, //i
 399          0x6e, 0x00, //n
 400          0x61, 0x00, //a
 401          0x2e, 0x00, //.
 402          0x63, 0x00, //c
 403          0x6f, 0x00, //o
 404          0x6d, 0x00, //m
 405          0x2f, 0x00, ///
 406          0x39, 0x00, //9
 407          0x33, 0x00, //3
 408          0x2f, 0x00  ///
 409          };
 410          /////////////////////////厂商字符串结束/////////////////////////////
 411          
 412          //字符串“《圈圈教你玩USB》之USB触摸屏设备”的Unicode编码
 413          //8位小端格式
 414          code uint8 ProductStringDescriptor[40]={
 415          40,         //该描述符的长度为40字节
 416          0x03,       //字符串描述符的类型编码为0x03
 417          0x0a, 0x30, //《
 418          0x08, 0x57, //圈
 419          0x08, 0x57, //圈
 420          0x59, 0x65, //教
 421          0x60, 0x4f, //你
 422          0xa9, 0x73, //玩
 423          0x55, 0x00, //U
 424          0x53, 0x00, //S
 425          0x42, 0x00, //B
 426          0x0b, 0x30, //》
 427          0x4b, 0x4e, //之
C51 COMPILER V7.06   USBCORE                                                               02/25/2012 23:06:11 PAGE 8   

 428          0x55, 0x00, //U
 429          0x53, 0x00, //S
 430          0x42, 0x00, //B
 431          0xe6, 0x89, //触
 432          0x78, 0x64, //摸
 433          0x4f, 0x5c, //屏
 434          0xbe, 0x8b, //设
 435          0x07, 0x59  //备
 436          };
 437          ////////////////////////产品字符串结束////////////////////////////
 438          
 439          //字符串“2012-01-16”的Unicode编码
 440          //8位小端格式
 441          code uint8 SerialNumberStringDescriptor[22]={
 442          22,         //该描述符的长度为22字节
 443          0x03,       //字符串描述符的类型编码为0x03
 444          0x32, 0x00, //2
 445          0x30, 0x00, //0
 446          0x31, 0x00, //1
 447          0x32, 0x00, //2
 448          0x2d, 0x00, //-
 449          0x30, 0x00, //0
 450          0x31, 0x00, //1
 451          0x2d, 0x00, //-
 452          0x31, 0x00, //1
 453          0x36, 0x00  //6
 454          };
 455          //////////////////////产品序列号字符串结束/////////////////////////
 456          
 457          /********************************************************************
 458          函数功能：延时x毫秒函数。
 459          入口参数：x：延时的毫秒数。
 460          返    回：无。
 461          备    注：无。
 462          ********************************************************************/
 463          void DelayXms(uint16 x)                
 464          {
 465   1       uint16 i;
 466   1       uint16 j;
 467   1       for(i=0;i<x;i++)
 468   1       for(j=0;j<227;j++); //循环语句延时
 469   1      }
 470          ////////////////////////End of function//////////////////////////////
 471          
 472          /********************************************************************
 473          函数功能：USB断开连接函数。
 474          入口参数：无。
 475          返    回：无。
 476          备    注：无。
 477          ********************************************************************/
 478          void UsbDisconnect(void)
 479          {
 480   1      #ifdef DEBUG0
               Prints("断开USB连接。\r\n");
              #endif
 483   1       D12WriteCommand(D12_SET_MODE);  //写设置模式命令
 484   1       D12WriteByte(0x06); //设置模式的第一字节
 485   1       D12WriteByte(0x47); //设置模式的第二字节
 486   1       DelayXms(1000);  //延迟1秒
 487   1      }
 488          ////////////////////////End of function//////////////////////////////
 489          
C51 COMPILER V7.06   USBCORE                                                               02/25/2012 23:06:11 PAGE 9   

 490          /********************************************************************
 491          函数功能：USB连接函数。
 492          入口参数：无。
 493          返    回：无。
 494          备    注：无。
 495          ********************************************************************/
 496          void UsbConnect(void)
 497          {
 498   1      #ifdef DEBUG0
               Prints("连接USB。\r\n");
              #endif
 501   1       D12WriteCommand(D12_SET_MODE);  //写设置模式命令
 502   1       D12WriteByte(0x16); //设置模式的第一字节
 503   1       D12WriteByte(0x47); //设置模式的第二字节
 504   1      }
 505          ////////////////////////End of function//////////////////////////////
 506          
 507          /********************************************************************
 508          函数功能：总线挂起中断处理函数。
 509          入口参数：无。
 510          返    回：无。
 511          备    注：无。
 512          ********************************************************************/
 513          void UsbBusSuspend(void)
 514          {
 515   1      #ifdef DEBUG0
               Prints("USB总线挂起。\r\n");
              #endif
 518   1      }
 519          ////////////////////////End of function//////////////////////////////
 520          
 521          /********************************************************************
 522          函数功能：总线复位中断处理函数。
 523          入口参数：无。
 524          返    回：无。
 525          备    注：无。
 526          ********************************************************************/
 527          void UsbBusReset(void)
 528          {
 529   1      #ifdef DEBUG0
               Prints("USB总线复位。\r\n");
              #endif
 532   1       Ep1InIsBusy=0; //复位后端点1输入缓冲区空闲。
 533   1      }
 534          ////////////////////////End of function//////////////////////////////
 535          
 536          /********************************************************************
 537          函数功能：根据pData和SendLength将数据发送到端点0的函数。
 538          入口参数：无。
 539          返    回：无。
 540          备    注：无。
 541          ********************************************************************/
 542          void UsbEp0SendData(void)
 543          {
 544   1       //将数据写到端点中去准备发送
 545   1       //写之前要先判断一下需要发送的数据是否比端点0
 546   1       //最大长度大，如果超过端点大小，则一次只能发送
 547   1       //最大包长的数据。端点0的最大包长在DeviceDescriptor[7]
 548   1       if(SendLength>DeviceDescriptor[7])
 549   1       {
 550   2        //按最大包长度发送
 551   2        D12WriteEndpointBuffer(1,DeviceDescriptor[7],pSendData);
C51 COMPILER V7.06   USBCORE                                                               02/25/2012 23:06:11 PAGE 10  

 552   2        //发送后剩余字节数减少最大包长
 553   2        SendLength-=DeviceDescriptor[7];
 554   2        //发送一次后指针位置要调整
 555   2        pSendData+= DeviceDescriptor[7];
 556   2       }
 557   1       else
 558   1       {
 559   2        if(SendLength!=0)
 560   2        {
 561   3         //不够最大包长，可以直接发送
 562   3         D12WriteEndpointBuffer(1,SendLength,pSendData);
 563   3         //发送完毕后，SendLength长度变为0
 564   3         SendLength=0;
 565   3        }
 566   2        else //如果要发送的数据包长度为0
 567   2        {
 568   3         if(NeedZeroPacket==1) //如果需要发送0长度数据
 569   3         {
 570   4          D12WriteEndpointBuffer(1,0,pSendData); //发送0长度数据包
 571   4          NeedZeroPacket=0; //清需要发送0长度数据包标志
 572   4         }
 573   3        }
 574   2       }
 575   1      }
 576          ////////////////////////End of function//////////////////////////////
 577          
 578          /********************************************************************
 579          函数功能：端点0输出中断处理函数。
 580          入口参数：无。
 581          返    回：无。
 582          备    注：无。
 583          ********************************************************************/
 584          void UsbEp0Out(void)
 585          {
 586   1      #ifdef DEBUG0
               Prints("USB端点0输出中断。\r\n");
              #endif
 589   1       //读取端点0输出最后传输状态，该操作清除中断标志
 590   1       //并判断第5位是否为1，如果是，则说明是建立包
 591   1       if(D12ReadEndpointLastStatus(0)&0x20)
 592   1       {
 593   2        D12ReadEndpointBuffer(0,16,Buffer); //读建立过程数据
 594   2        D12AcknowledgeSetup(); //应答建立包
 595   2        D12ClearBuffer(); //清缓冲区
 596   2        //将缓冲数据填到设备请求的各字段中
 597   2        bmRequestType=Buffer[0];
 598   2        bRequest=Buffer[1];
 599   2        wValue=Buffer[2]+(((uint16)Buffer[3])<<8);
 600   2        wIndex=Buffer[4]+(((uint16)Buffer[5])<<8);
 601   2        wLength=Buffer[6]+(((uint16)Buffer[7])<<8);
 602   2        //下面的代码判断具体的请求，并根据不同的请求进行相关操作
 603   2        //如果D7位为1，则说明是输入请求
 604   2        if((bmRequestType&0x80)==0x80)
 605   2        {
 606   3         //根据bmRequestType的D6~5位散转，D6~5位表示请求的类型
 607   3         //0为标准请求，1为类请求，2为厂商请求。
 608   3         switch((bmRequestType>>5)&0x03)
 609   3         {
 610   4          case 0:  //标准请求
 611   4           #ifdef DEBUG0
                    Prints("USB标准输入请求：");
                   #endif
C51 COMPILER V7.06   USBCORE                                                               02/25/2012 23:06:11 PAGE 11  

 614   4           //USB协议定义了几个标准输入请求，我们实现这些标准请求即可
 615   4           //请求的代码在bRequest中，对不同的请求代码进行散转
 616   4           //事实上，我们还需要对接收者进行散转，因为不同的请求接收者
 617   4           //是不一样的。接收者在bmRequestType的D4~D0位中定义。
 618   4           //我们这里为了简化操作，有些就省略了对接收者的判断。
 619   4           //例如获取描述符的请求，只根据描述符的类型来区别。
 620   4           switch(bRequest)
 621   4           {
 622   5            case GET_CONFIGURATION: //获取配置
 623   5             #ifdef DEBUG0
                      Prints("获取配置。\r\n");
                     #endif
 626   5            break;
 627   5            
 628   5            case GET_DESCRIPTOR:  //获取描述符
 629   5             #ifdef DEBUG0
                      Prints("获取描述符――");
                     #endif
 632   5             //对描述符类型进行散转，对于全速设备，
 633   5             //标准请求只支持发送到设备的设备、配置、字符串三种描述符
 634   5             switch((wValue>>8)&0xFF)
 635   5              {
 636   6               case DEVICE_DESCRIPTOR: //设备描述符
 637   6                #ifdef DEBUG0
                         Prints("设备描述符。\r\n");
                        #endif
 640   6                pSendData=DeviceDescriptor;  //需要发送的数据
 641   6                //判断请求的字节数是否比实际需要发送的字节数多
 642   6                //这里请求的是设备描述符，因此数据长度就是
 643   6                //DeviceDescriptor[0]。如果请求的比实际的长，
 644   6                //那么只返回实际长度的数据
 645   6                if(wLength>DeviceDescriptor[0])
 646   6                {
 647   7                 SendLength=DeviceDescriptor[0];
 648   7                 if(SendLength%DeviceDescriptor[7]==0) //并且刚好是整数个数据包时
 649   7                 {
 650   8                  NeedZeroPacket=1; //需要返回0长度的数据包
 651   8                 }
 652   7                }
 653   6                else
 654   6                {
 655   7                 SendLength=wLength;
 656   7                }
 657   6                //将数据通过EP0返回
 658   6                UsbEp0SendData();
 659   6               break;
 660   6               
 661   6               case CONFIGURATION_DESCRIPTOR:  //配置描述符
 662   6                #ifdef DEBUG0
                         Prints("配置描述符。\r\n");
                        #endif
 665   6                pSendData=ConfigurationDescriptor; //需要发送的数据为配置描述符
 666   6                //判断请求的字节数是否比实际需要发送的字节数多
 667   6                //这里请求的是配置描述符集合，因此数据长度就是
 668   6                //ConfigurationDescriptor[3]*256+ConfigurationDescriptor[2]。
 669   6                //如果请求的比实际的长，那么只返回实际长度的数据
 670   6                SendLength=ConfigurationDescriptor[3];
 671   6                SendLength=SendLength*256+ConfigurationDescriptor[2];
 672   6                if(wLength>SendLength)
 673   6                {
 674   7                 if(SendLength%DeviceDescriptor[7]==0) //并且刚好是整数个数据包时
 675   7                 {
C51 COMPILER V7.06   USBCORE                                                               02/25/2012 23:06:11 PAGE 12  

 676   8                  NeedZeroPacket=1; //需要返回0长度的数据包
 677   8                 }
 678   7                }
 679   6                else
 680   6                {
 681   7                 SendLength=wLength;
 682   7                }
 683   6                //将数据通过EP0返回
 684   6                UsbEp0SendData();
 685   6               break;
 686   6               
 687   6               case STRING_DESCRIPTOR:  //字符串描述符
 688   6                #ifdef DEBUG0
                         Prints("字符串描述符");
                        #endif
 691   6                switch(wValue&0xFF)  //根据wValue的低字节（索引值）散转
 692   6                {
 693   7                 case 0:  //获取语言ID
 694   7                  #ifdef DEBUG0
                           Prints("(语言ID)。\r\n");
                          #endif
 697   7                  pSendData=LanguageId;
 698   7                  SendLength=LanguageId[0];
 699   7                 break;
 700   7                 
 701   7                 case 1:  //厂商字符串的索引值为1，所以这里为厂商字符串
 702   7                 #ifdef DEBUG0
                           Prints("(厂商描述)。\r\n");
                          #endif
 705   7                  pSendData=ManufacturerStringDescriptor;
 706   7                  SendLength=ManufacturerStringDescriptor[0];
 707   7                 break;
 708   7                 
 709   7                 case 2:  //产品字符串的索引值为2，所以这里为产品字符串
 710   7                 #ifdef DEBUG0
                           Prints("(产品描述)。\r\n");
                          #endif
 713   7                  pSendData=ProductStringDescriptor;
 714   7                  SendLength=ProductStringDescriptor[0];
 715   7                 break;
 716   7                 
 717   7                 case 3:  //产品序列号的索引值为3，所以这里为序列号
 718   7                 #ifdef DEBUG0
                           Prints("(产品序列号)。\r\n");
                          #endif
 721   7                  pSendData=SerialNumberStringDescriptor;
 722   7                  SendLength=SerialNumberStringDescriptor[0];
 723   7                 break;
 724   7                 
 725   7                 default :
 726   7                  #ifdef DEBUG0
                           Prints("(未知的索引值)。\r\n");
                          #endif
 729   7                  //对于未知索引值的请求，返回一个0长度的包
 730   7                  SendLength=0;
 731   7                  NeedZeroPacket=1;
 732   7                 break;
 733   7                }
 734   6                //判断请求的字节数是否比实际需要发送的字节数多
 735   6                //如果请求的比实际的长，那么只返回实际长度的数据
 736   6                if(wLength>SendLength)
 737   6                {
C51 COMPILER V7.06   USBCORE                                                               02/25/2012 23:06:11 PAGE 13  

 738   7                 if(SendLength%DeviceDescriptor[7]==0) //并且刚好是整数个数据包时
 739   7                 {
 740   8                  NeedZeroPacket=1; //需要返回0长度的数据包
 741   8                 }
 742   7                }
 743   6                else
 744   6                {
 745   7                 SendLength=wLength;
 746   7                }
 747   6                //将数据通过EP0返回
 748   6                UsbEp0SendData();         
 749   6               break;
 750   6      
 751   6               case REPORT_DESCRIPTOR:  //报告描述符
 752   6                #ifdef DEBUG0
                         Prints("报告描述符。\r\n");
                        #endif
 755   6                pSendData=ReportDescriptor; //需要发送的数据为报告描述符
 756   6                SendLength=sizeof(ReportDescriptor); //需要返回的数据长度         
 757   6                //判断请求的字节数是否比实际需要发送的字节数多
 758   6                //如果请求的比实际的长，那么只返回实际长度的数据
 759   6                if(wLength>SendLength)
 760   6                {
 761   7                 if(SendLength%DeviceDescriptor[7]==0) //并且刚好是整数个数据包时
 762   7                 {
 763   8                  NeedZeroPacket=1; //需要返回0长度的数据包
 764   8                 }
 765   7                }
 766   6                else
 767   6                {
 768   7                 SendLength=wLength;
 769   7                }
 770   6                //将数据通过EP0返回
 771   6                UsbEp0SendData();
 772   6               break;
 773   6                       
 774   6               default:  //其它描述符
 775   6                #ifdef DEBUG0
                         Prints("其他描述符，描述符代码：");
                         PrintHex((wValue>>8)&0xFF);
                         Prints("\r\n");
                        #endif
 780   6               break;
 781   6              }
 782   5             break;
 783   5            
 784   5            case GET_INTERFACE: //获取接口
 785   5             #ifdef DEBUG0
                      Prints("获取接口。\r\n");
                     #endif
 788   5            break;
 789   5            
 790   5            case GET_STATUS: //获取状态
 791   5             #ifdef DEBUG0
                      Prints("获取状态。\r\n");
                     #endif
 794   5            break;
 795   5            
 796   5            case SYNCH_FRAME: //同步帧
 797   5             #ifdef DEBUG0
                      Prints("同步帧。\r\n");
                     #endif
C51 COMPILER V7.06   USBCORE                                                               02/25/2012 23:06:11 PAGE 14  

 800   5            break;
 801   5            
 802   5            default:  //未定义的标准请求
 803   5             #ifdef DEBUG0
                      Prints("错误：未定义的标准输入请求。\r\n");
                     #endif       
 806   5            break;
 807   5           }
 808   4          break;
 809   4          
 810   4          case 1:  //类请求
 811   4           #ifdef DEBUG0
                    Prints("USB类输入请求：\r\n");
                   #endif
 814   4          break;
 815   4          
 816   4          case 2:  //厂商请求
 817   4           #ifdef DEBUG0
                    Prints("USB厂商输入请求：\r\n");
                   #endif
 820   4          break;
 821   4          
 822   4          default: //未定义的请求。这里只显示一个报错信息。
 823   4           #ifdef DEBUG0
                    Prints("错误：未定义的输入请求。\r\n");
                   #endif
 826   4          break;
 827   4         }
 828   3        }
 829   2        //否则说明是输出请求
 830   2        else //if(bmRequestType&0x80==0x80)之else
 831   2        {
 832   3         //根据bmRequestType的D6~5位散转，D6~5位表示请求的类型
 833   3         //0为标准请求，1为类请求，2为厂商请求。
 834   3         switch((bmRequestType>>5)&0x03)
 835   3         {
 836   4          case 0:  //标准请求
 837   4           #ifdef DEBUG0
                    Prints("USB标准输出请求：");
                   #endif
 840   4           //USB协议定义了几个标准输出请求，我们实现这些标准请求即可
 841   4           //请求的代码在bRequest中，对不同的请求代码进行散转
 842   4           switch(bRequest)
 843   4           {
 844   5            case CLEAR_FEATURE: //清除特性
 845   5             #ifdef DEBUG0
                      Prints("清除特性。\r\n");
                     #endif
 848   5            break;
 849   5            
 850   5            case SET_ADDRESS:  //设置地址
 851   5             #ifdef DEBUG0
                      Prints("设置地址。地址为：");
                      PrintHex(wValue&0xFF); //显示所设置的地址
                      Prints("\r\n");
                     #endif
 856   5             D12SetAddress(wValue&0xFF); //wValue中的低字节是设置的地址值
 857   5             //设置地址没有数据过程，直接进入到状态过程，返回一个0长度的数据包
 858   5             SendLength=0;
 859   5             NeedZeroPacket=1;
 860   5             //将数据通过EP0返回
 861   5             UsbEp0SendData();
C51 COMPILER V7.06   USBCORE                                                               02/25/2012 23:06:11 PAGE 15  

 862   5            break;
 863   5            
 864   5            case SET_CONFIGURATION: //设置配置
 865   5             #ifdef DEBUG0
                      Prints("设置配置。\r\n");
                     #endif
 868   5             //使能非0端点。非0端点只有在设置为非0的配置后才能使能。
 869   5             //wValue的低字节为配置的值，如果该值为非0，才能使能非0端点。
 870   5             //保存当前配置值
 871   5             ConfigValue=wValue&0xFF;
 872   5             D12SetEndpointEnable(ConfigValue);
 873   5             //返回一个0长度的状态数据包
 874   5             SendLength=0;
 875   5             NeedZeroPacket=1;
 876   5             //将数据通过EP0返回
 877   5             UsbEp0SendData();
 878   5            break;
 879   5            
 880   5            case SET_DESCRIPTOR: //设置描述符
 881   5             #ifdef DEBUG0
                      Prints("设置描述符。\r\n");
                     #endif
 884   5            break;
 885   5            
 886   5            case SET_FEATURE: //设置特性
 887   5             #ifdef DEBUG0
                      Prints("设置特性。\r\n");
                     #endif
 890   5            break;
 891   5      
 892   5            case SET_INTERFACE: //设置接口
 893   5             #ifdef DEBUG0
                      Prints("设置接口。\r\n");
                     #endif
 896   5            break;      
 897   5            
 898   5            default:  //未定义的标准请求
 899   5             #ifdef DEBUG0
                      Prints("错误：未定义的标准输出请求。\r\n");
                     #endif       
 902   5            break;
 903   5           }
 904   4          break;
 905   4          
 906   4          case 1:  //类请求
 907   4           #ifdef DEBUG0
                    Prints("USB类输出请求：");
                   #endif
 910   4           switch(bRequest)
 911   4           {
 912   5            case SET_IDLE:
 913   5             #ifdef DEBUG0
                      Prints("设置空闲。\r\n");
                     #endif
 916   5             //只需要返回一个0长度的数据包即可
 917   5             SendLength=0;
 918   5             NeedZeroPacket=1;
 919   5             //将数据通过EP0返回
 920   5             UsbEp0SendData();
 921   5            break;
 922   5            
 923   5            default:
C51 COMPILER V7.06   USBCORE                                                               02/25/2012 23:06:11 PAGE 16  

 924   5             #ifdef DEBUG0
                      Prints("未知请求。\r\n");
                     #endif
 927   5            break;
 928   5           }
 929   4          break;
 930   4          
 931   4          case 2:  //厂商请求
 932   4           #ifdef DEBUG0
                    Prints("USB厂商输出请求：\r\n");
                   #endif
 935   4          break;
 936   4          
 937   4          default: //未定义的请求。这里只显示一个报错信息。
 938   4           #ifdef DEBUG0
                    Prints("错误：未定义的输出请求。\r\n");
                   #endif
 941   4          break;
 942   4         }
 943   3        }
 944   2       }
 945   1       //普通数据输出
 946   1       else //if(D12ReadEndpointLastStatus(0)&0x20)之else
 947   1       {
 948   2        D12ReadEndpointBuffer(0,16,Buffer);
 949   2        D12ClearBuffer();
 950   2       }
 951   1      }
 952          ////////////////////////End of function//////////////////////////////
 953          
 954          /********************************************************************
 955          函数功能：端点0输入中断处理函数。
 956          入口参数：无。
 957          返    回：无。
 958          备    注：无。
 959          ********************************************************************/
 960          void UsbEp0In(void)
 961          {
 962   1      #ifdef DEBUG0
               Prints("USB端点0输入中断。\r\n");
              #endif
 965   1       //读最后发送状态，这将清除端点0的中断标志位
 966   1       D12ReadEndpointLastStatus(1);
 967   1       //发送剩余的字节数
 968   1       UsbEp0SendData();
 969   1      }
 970          ////////////////////////End of function//////////////////////////////
 971          
 972          /********************************************************************
 973          函数功能：端点1输出中断处理函数。
 974          入口参数：无。
 975          返    回：无。
 976          备    注：无。
 977          ********************************************************************/
 978          void UsbEp1Out(void)
 979          {
 980   1      #ifdef DEBUG0
               Prints("USB端点1输出中断。\r\n");
              #endif
 983   1      }
 984          ////////////////////////End of function//////////////////////////////
 985          
C51 COMPILER V7.06   USBCORE                                                               02/25/2012 23:06:11 PAGE 17  

 986          /********************************************************************
 987          函数功能：端点1输入中断处理函数。
 988          入口参数：无。
 989          返    回：无。
 990          备    注：无。
 991          ********************************************************************/
 992          void UsbEp1In(void)
 993          {
 994   1      #ifdef DEBUG0
               Prints("USB端点1输入中断。\r\n");
              #endif
 997   1       //读最后发送状态，这将清除端点1输入的中断标志位
 998   1       D12ReadEndpointLastStatus(3);
 999   1       //端点1输入处于空闲状态
1000   1       Ep1InIsBusy=0;
1001   1      }
1002          ////////////////////////End of function//////////////////////////////
1003          
1004          /********************************************************************
1005          函数功能：端点2输出中断处理函数。
1006          入口参数：无。
1007          返    回：无。
1008          备    注：无。
1009          ********************************************************************/
1010          void UsbEp2Out(void)
1011          {
1012   1      #ifdef DEBUG0
               Prints("USB端点2输出中断。\r\n");
              #endif
1015   1      }
1016          ////////////////////////End of function//////////////////////////////
1017          
1018          /********************************************************************
1019          函数功能：端点2输入中断处理函数。
1020          入口参数：无。
1021          返    回：无。
1022          备    注：无。
1023          ********************************************************************/
1024          void UsbEp2In(void)
1025          {
1026   1      #ifdef DEBUG0
               Prints("USB端点2输入中断。\r\n");
              #endif
1029   1      }
1030          ////////////////////////End of function//////////////////////////////


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    758    ----
   CONSTANT SIZE    =    256    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     16    ----
   IDATA SIZE       =     16    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
