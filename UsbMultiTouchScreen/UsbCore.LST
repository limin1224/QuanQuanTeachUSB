C51 COMPILER V7.06   USBCORE                                                               02/25/2012 23:05:51 PAGE 1   


C51 COMPILER V7.06, COMPILATION OF MODULE USBCORE
OBJECT MODULE PLACED IN UsbCore.OBJ
COMPILER INVOKED BY: d:\Keil\C51\BIN\C51.EXE UsbCore.c BROWSE DEBUG OBJECTEXTEND TABS(1)

stmt level    source

   1          /******************************************************************
   2             本程序只供学习使用，未经作者许可，不得用于其它任何用途
   3             
   4                  欢迎访问我的USB专区：http://group.ednchina.com/93/
   5                  欢迎访问我的blog：   http://www.ednchina.com/blog/computer00
   6                                       http://computer00.21ic.org
   7          
   8                  感谢PCB赞助商――电子园： http://bbs.cepark.com/
   9          
  10          UsbCore.c file
  11          
  12          作者：电脑圈圈
  13          建立日期: 2008.06.29
  14          修改日期: 2012.01.26
  15          版本：V1.1
  16          版权所有，盗版必究。
  17          Copyright(C) 电脑圈圈 2008-2018
  18          All rights reserved            
  19          *******************************************************************/
  20          
  21          #include "config.h"
  22          #include "pdiusbd12.h"
  23          #include "uart.h"
  24          #include "usbcore.h"
  25          
  26          idata uint8 Buffer[16];  //读端点0用的缓冲区
  27          
  28          //USB设备请求的各字段
  29          uint8  bmRequestType;
  30          uint8  bRequest;
  31          uint16 wValue;
  32          uint16 wIndex;
  33          uint16 wLength;
  34          //当前发送数据的位置
  35          uint8 * pSendData;
  36          //需要发送数据的长度
  37          uint16 SendLength;
  38          //是否需要发送0数据包的标志。在USB控制传输的数据过程中，
  39          //当返回的数据包字节数少于最大包长时，会认为数据过程结束。
  40          //当请求的字节数比实际需要返回的字节数长，而实际返回的字节
  41          //数又刚好是端点0大小的整数倍时，就需要返回一个0长度的数据包
  42          //来结束数据过程。因此这里增加一个标志，供程序决定是否需要返回
  43          //一个0长度的数据包。
  44          uint8 NeedZeroPacket;
  45          
  46          //当前的配置值。只有在设置非0配置后
  47          uint8 ConfigValue;
  48          
  49          //端点1缓冲是否忙的标志。当缓冲区中有数据时，该标志为真。
  50          //当缓冲区中空闲时，该标志为假。
  51          uint8 Ep1InIsBusy;
  52          
  53          //USB设备描述符的定义
  54          code uint8 DeviceDescriptor[0x12]=  //设备描述符为18字节
  55          {
C51 COMPILER V7.06   USBCORE                                                               02/25/2012 23:05:51 PAGE 2   

  56          //bLength字段。设备描述符的长度为18(0x12)字节
  57           0x12,
  58           
  59          //bDescriptorType字段。设备描述符的编号为0x01
  60           0x01,
  61           
  62          //bcdUSB字段。这里设置版本为USB1.1，即0x0110。
  63          //由于是小端结构，所以低字节在先，即0x10，0x01。
  64           0x10,
  65           0x01,
  66           
  67          //bDeviceClass字段。我们不在设备描述符中定义设备类，
  68          //而在接口描述符中定义设备类，所以该字段的值为0。
  69           0x00,
  70           
  71          //bDeviceSubClass字段。bDeviceClass字段为0时，该字段也为0。
  72           0x00,
  73           
  74          //bDeviceProtocol字段。bDeviceClass字段为0时，该字段也为0。
  75           0x00,
  76           
  77          //bMaxPacketSize0字段。PDIUSBD12的端点0大小的16字节。
  78           0x10,
  79           
  80          //idVender字段。厂商ID号，我们这里取0x8888，仅供实验用。
  81          //实际产品不能随便使用厂商ID号，必须跟USB协会申请厂商ID号。
  82          //注意小端模式，低字节在先。
  83           0x88,
  84           0x88,
  85           
  86          //idProduct字段。产品ID号，由于是第二版的第二个实验，我们这里取0x0102。
  87          //注意小端模式，低字节应该在前。
  88           0x02,
  89           0x01,
  90           
  91          //bcdDevice字段。我们这个USB触摸屏刚开始做，就叫它1.0版吧，即0x0100。
  92          //小端模式，低字节在先。
  93           0x00,
  94           0x01,
  95           
  96          //iManufacturer字段。厂商字符串的索引值，为了方便记忆和管理，
  97          //字符串索引就从1开始吧。
  98           0x01,
  99          
 100          //iProduct字段。产品字符串的索引值。刚刚用了1，这里就取2吧。
 101          //注意字符串索引值不要使用相同的值。
 102           0x02,
 103           
 104          //iSerialNumber字段。设备的序列号字符串索引值。
 105          //这里取3就可以了。
 106           0x03,
 107          
 108          //bNumConfigurations字段。该设备所具有的配置数。
 109          //我们只需要一种配置就行了，因此该值设置为1。
 110           0x01
 111          };
 112          //////////////////////////设备描述符完毕//////////////////////////////
 113          
 114          //WIN7多点触摸的白皮书文档下载地址：
 115          //http://download.microsoft.com/download/a/d/f/adf1347d-08dc-41a4-9084-623b1194d4b2/DigitizerDrvs_touch.do
             -cx
 116          
C51 COMPILER V7.06   USBCORE                                                               02/25/2012 23:05:51 PAGE 3   

 117          //USB报告描述符的定义
 118          code uint8 ReportDescriptor[]=
 119          {
 120           /***********************以下是单点触摸报告描述符********************/
 121           //每行开始的第一字节为该条目的前缀，前缀的格式为：
 122           //D7~D4：bTag。D3~D2：bType；D1~D0：bSize。以下分别对每个条目注释。
 123           
 124           //这是一个全局（bType为1）条目，选择用途页为普通桌面Generic Desktop Page(0x01)
 125           //后面跟一字节数据（bSize为1），后面的字节数就不注释了，
 126           //自己根据bSize来判断。
 127           0x05, 0x01, // USAGE_PAGE (Generic Desktop)
 128           
 129           //这是一个局部（bType为2）条目，说明接下来的应用集合用途用于鼠标
 130           0x09, 0x02, // USAGE (Mouse)
 131           
 132           //这是一个主（bType为0）条目，开集合，后面跟的数据0x01表示
 133           //该集合是一个应用集合。它的性质在前面由用途页和用途定义为
 134           //普通桌面用的鼠标。
 135           0xa1, 0x01, // COLLECTION (Application)
 136           
 137           //全局条目，定义单点触摸的报告ID为REPORTID_STOUCH(usbcore.h中定义)
 138           0x85, REPORTID_STOUCH, //   REPORT_ID (Single Touch)
 139           
 140           //这是一个局部条目。说明用途为指针集合
 141           0x09, 0x01, //   USAGE (Pointer)
 142           
 143           //这是一个主条目，开集合，后面跟的数据0x00表示该集合是一个
 144           //物理集合，用途由前面的局部条目定义为指针集合。
 145           0xa1, 0x00, //   COLLECTION (Physical)
 146           
 147           //这是一个全局条目，选择用途页为按键（Button Page(0x09)）
 148           0x05, 0x09, //     USAGE_PAGE (Button)
 149           
 150           //这是一个局部条目，说明用途的最小值为1。实际上是鼠标左键。
 151           0x19, 0x01, //     USAGE_MINIMUM (Button 1)
 152           
 153           //这是一个局部条目，说明用途的最大值为3。实际上是鼠标中键。
 154           0x29, 0x03, //     USAGE_MAXIMUM (Button 3)
 155           
 156           //这是一个全局条目，说明返回的数据的逻辑值（就是我们返回的数据域的值啦）
 157           //最小为0。因为我们这里用Bit来表示一个数据域，因此最小为0，最大为1。
 158           0x15, 0x00, //     LOGICAL_MINIMUM (0)
 159           
 160           //这是一个全局条目，说明逻辑值最大为1。
 161           0x25, 0x01, //     LOGICAL_MAXIMUM (1)
 162           
 163           //这是一个全局条目，说明数据域的数量为三个。
 164           0x95, 0x03, //     REPORT_COUNT (3)
 165           
 166           //这是一个全局条目，说明每个数据域的长度为1个bit。
 167           0x75, 0x01, //     REPORT_SIZE (1)
 168           
 169           //这是一个主条目，说明有3个长度为1bit的数据域（数量和长度
 170           //由前面的两个全局条目所定义）用来做为输入，
 171           //属性为：Data,Var,Abs。Data表示这些数据可以变动，Var表示
 172           //这些数据域是独立的，每个域表示一个意思。Abs表示绝对值。
 173           //这样定义的结果就是，第一个数据域bit0表示按键1（左键）是否按下，
 174           //第二个数据域bit1表示按键2（右键）是否按下，第三个数据域bit2表示
 175           //按键3（中键）是否按下。
 176           0x81, 0x02, //     INPUT (Data,Var,Abs)
 177           
 178           //这是一个全局条目，说明数据域数量为1个
C51 COMPILER V7.06   USBCORE                                                               02/25/2012 23:05:51 PAGE 4   

 179           0x95, 0x01, //     REPORT_COUNT (1)
 180           
 181           //这是一个全局条目，说明每个数据域的长度为5bit。
 182           0x75, 0x05, //     REPORT_SIZE (5)
 183           
 184           //这是一个主条目，输入用，由前面两个全局条目可知，长度为5bit，
 185           //数量为1个。它的属性为常量（即返回的数据一直是0）。
 186           //这个只是为了凑齐一个字节（前面用了3个bit）而填充的一些数据
 187           //而已，所以它是没有实际用途的。
 188           0x81, 0x03, //     INPUT (Cnst,Var,Abs)
 189            
 190           //这是一个全局条目，选择用途页为普通桌面Generic Desktop Page(0x01)
 191           0x05, 0x01, //     USAGE_PAGE (Generic Desktop)
 192           
 193           //这是一个局部条目，说明用途为X轴
 194           0x09, 0x30, //     USAGE (X)
 195           
 196           //这是一个局部条目，说明用途为Y轴
 197           0x09, 0x31, //     USAGE (Y)
 198          
 199           //下面两个为全局条目，说明返回的逻辑最小和最大值。
 200           //这里定义X和Y轴的逻辑最小值为0，即坐标原点
 201           //X和Y轴的逻辑最大值为4096，即屏幕右下方的坐标为（4096，4096）。
 202           //由于4096超过了一字节的范围，所以需要用2字节的格式表示最大值
 203           0x15, 0x00, //     LOGICAL_MINIMUM (0)
 204           0x26, 0x00, 0x10, //     LOGICAL_MAXIMUM (4096)
 205          
 206           //下面两个为全局条目，说明返回的物理最小和最大值。
 207           //这里定义X和Y轴的物理最小值为0，即坐标原点
 208           //X和Y轴的物理最大值为4096，即屏幕右下方的坐标为（4096，4096）。
 209           //由于4096超过了一字节的范围，所以需要用2字节的格式表示最大值
 210           0x35, 0x00,    //Physical Minimum (0)
 211           0x46, 0x00, 0x10, //Physical Maximum(4096)
 212          
 213           //这是一个全局条目，说明数据域的长度为16bit。
 214           0x75, 0x10, //     REPORT_SIZE (16)
 215           
 216           //这是一个全局条目，说明数据域的个数为2个。
 217           0x95, 0x02, //     REPORT_COUNT (2)
 218           
 219           //这是一个主条目。它说明这两个16bit的数据域是输入用的，
 220           //属性为：Data,Var,Abs。Data说明数据是可以变的，Var说明
 221           //这些数据域是独立的，Abs表示这些值是绝对值。
 222           0x81, 0x02, //     INPUT (Data,Var,Abs)
 223           
 224           //下面这两个主条目用来关闭前面的集合用。
 225           //我们开了两个集合，所以要关两次。bSize为0，所以后面没数据。
 226           0xc0,       //   END_COLLECTION
 227           0xc0,       // END_COLLECTION
 228           /***********************单点触摸描述完毕***************************/
 229          
 230           /***********************以下是多点触摸报告描述*********************/
 231           //这是一个全局条目，选择用途页为Digitizers
 232           0x05, 0x0d,  // USAGE_PAGE (Digitizers)
 233          
 234           //这是一个局部条目，说明接下来的应用集合用途用于Touch Screen
 235           0x09, 0x04,  // USAGE (Touch Screen)
 236          
 237           //这是一个主条目，开集合，后面跟的数据0x01表示该集合是一个应用集合。
 238           //它的性质在前面由用途页和用途定义为Digitizers的Touch Screen。
 239           0xa1, 0x01,  // COLLECTION (Application)
 240           
C51 COMPILER V7.06   USBCORE                                                               02/25/2012 23:05:51 PAGE 5   

 241           //全局条目，定义多点触摸的报告ID为REPORTID_MTOUCH(usbcore.h中定义)
 242           0x85, REPORTID_MTOUCH,  //   REPORT_ID (Touch)
 243           
 244           //这是一个局部条目，选择用途为Digitizers页中的Finger
 245           0x09, 0x22,  //   USAGE (Finger)
 246           
 247           //这是一个主条目，开集合，后面跟的数据0x02表示该集合是一个逻辑集合。
 248           //它的性质在前面由用途页和用途定义为Digitizers的Finger。
 249           0xa1, 0x02,  //     COLLECTION (Logical)
 250           
 251           //这是一个局部条目，选择用途为Digitizers页中的Tip Switch，
 252           //本来用来表示触摸笔是否接触到屏幕，这里用来表示是否有手指触摸。
 253           0x09, 0x42,  //       USAGE (Tip Switch)
 254           
 255           //这是一个全局条目，说明返回的数据的逻辑最小值为0。
 256           0x15, 0x00,  //       LOGICAL_MINIMUM (0)
 257           
 258           //这是一个全局条目，说明返回的数据的逻辑最大值为1。
 259           0x25, 0x01,  //       LOGICAL_MAXIMUM (1)
 260           
 261           //这是一个全局条目，说明每个数据域的长度为1个bit。
 262           0x75, 0x01,  //       REPORT_SIZE (1)
 263           
 264           //这是一个全局条目，说明数据域的数量为1个。
 265           0x95, 0x01,  //       REPORT_COUNT (1)
 266           
 267           //这是一个主条目，说明有1个长度为1bit的数据域用于输入。
 268           //通过前面的描述我们可以知道，这个bit是用来表示是否触摸的，
 269           //0表示没有触摸，1表示触摸。
 270           0x81, 0x02,  //       INPUT (Data,Var,Abs)
 271           
 272           //这是一个局部条目，选择用途为Digitizers页中的In Range，
 273           //用来表示触摸的区域是否有效。
 274           0x09, 0x32,  //       USAGE (In Range)
 275           
 276           //这是一个主条目，说明有1个长度为1bit的数据域用于输入。
 277           //通过前面的描述我们可以知道，这个bit是用来表示触摸区域是否有效的，
 278           //0表示无效，1表示有效。
 279           0x81, 0x02,  //       INPUT (Data,Var,Abs)
 280           
 281           //这是一个局部条目，选择用途为Digitizers页中的Touch Valid，
 282           //用来表示触摸是否有效。
 283           0x09, 0x47,  //       USAGE (Touch Valid)
 284           
 285           //这是一个主条目，说明有1个长度为1bit的数据域用于输入。
 286           //通过前面的描述我们可以知道，这个bit是用来表示触摸是否有效的，
 287           //0表示无效，1表示有效。
 288           0x81, 0x02,  //       INPUT (Data,Var,Abs)
 289           
 290           //这是一个全局条目，说明数据域的数量为5个。
 291           0x95, 0x05,  //       REPORT_COUNT (5)
 292           
 293           //这是一个主条目，输入用，由前面两个全局条目可知，长度为1bit，
 294           //数量为5个。它的属性为常量（即返回的数据一直是0）。
 295           //这个只是为了凑齐一个字节（前面用了3个bit）而填充的一些数据
 296           //而已，所以它是没有实际用途的。
 297           0x81, 0x03,  //       INPUT (Cnst,Ary,Abs)
 298           
 299           //这是一个全局条目，说明返回的数据的逻辑最大值为MAX_TOUCH_POINT。
 300           0x25, MAX_TOUCH_POINT,  // LOGICAL_MAXIMUM (MAX_TOUCH_POINT)
 301           
 302           //这是一个全局条目，说明每个数据域的长度为8个bit。
C51 COMPILER V7.06   USBCORE                                                               02/25/2012 23:05:51 PAGE 6   

 303           0x75, 0x08,  //       REPORT_SIZE (8)
 304           
 305           //这是一个局部条目，选择用途为Digitizers页中的Contact Identifier，
 306           //用来表示触摸的ID号。
 307           0x09, 0x51,  //       USAGE (Contact Identifier)
 308           
 309           //这是一个全局条目，说明数据域的数量为1个。
 310           0x95, 0x01,  //       REPORT_COUNT (1)
 311           
 312           //这是一个主条目，说明有1个长度为8bit的数据域用于输入。
 313           //通过前面的描述我们可以知道，这个8bit是用来表示触摸ID号的，
 314           0x81, 0x02,  //       INPUT (Data,Var,Abs)
 315           
 316           //这是一个全局条目，选择用途页为Generic Desktop
 317           0x05, 0x01,  //       USAGE_PAGE (Generic Desktop)
 318           
 319           //这是一个全局条目，说明返回的数据的逻辑最大值为4096。
 320           0x26, 0x00, 0x10,  //       LOGICAL_MAXIMUM (4096)
 321           
 322           //这是一个全局条目，说明每个数据域的长度为16个bit。
 323           0x75, 0x10,  //       REPORT_SIZE (16)
 324           
 325           //这是一个全局条目，说明物理单位的指数为0
 326           0x55, 0x00,  //       UNIT_EXPONENT (0)
 327           
 328           //这是一个全局条目，说明没有物理单位
 329           0x65, 0x00,  //       UNIT (None)
 330           
 331           //这是一个局部条目，选择用途为通用桌面中的X轴
 332           0x09, 0x30,  //       USAGE (X)
 333           
 334           //这是一个全局条目，说明物理最小值为0。由于这里用不到物理最小、
 335           //最大值，所以将物理最小、最大值描述成0，并将单位描述成无。
 336           0x35, 0x00,  //       PHYSICAL_MINIMUM (0)
 337           
 338           //这是一个全局条目，说明物理最大值为0。
 339           0x46, 0x00, 0x00,  //       PHYSICAL_MAXIMUM (0)
 340           
 341           //这是一个主条目。它说明这个16bit的数据域是输入用的，
 342           //属性为：Data,Var,Abs。Data说明数据是可以变的，Var说明
 343           //这些数据域是独立的，Abs表示这些值是绝对值。它其实就是
 344           //我们要返回的X坐标数据。
 345           0x81, 0x02,  //       INPUT (Data,Var,Abs)
 346           
 347           //这是一个局部条目，选择用途为通用桌面中的Y轴
 348           0x09, 0x31,  //       USAGE (Y)
 349           
 350           //这是一个全局条目，说明物理最大值为0。
 351           0x46, 0x00, 0x00,  //       PHYSICAL_MAXIMUM (0)
 352           
 353           //这是一个主条目。它说明这个16bit的数据域是输入用的，
 354           //属性为：Data,Var,Abs。Data说明数据是可以变的，Var说明
 355           //这些数据域是独立的，Abs表示这些值是绝对值。它其实就是
 356           //我们要返回的Y坐标数据。
 357           0x81, 0x02,  //       INPUT (Data,Var,Abs)
 358           
 359           //这是一个主条目，关闭前面开的逻辑集合
 360           0xc0,        //    END_COLLECTION
 361           
 362           //从这里一直到下面的END_COLLECTION，基本上是上一个逻辑集合的重复，
 363           //这里就不再给出注释了，请读者自行分析。
 364           0xa1, 0x02,  //    COLLECTION (Logical)
C51 COMPILER V7.06   USBCORE                                                               02/25/2012 23:05:51 PAGE 7   

 365           0x05, 0x0d,  //     USAGE_PAGE (Digitizers)
 366           0x09, 0x42,  //       USAGE (Tip Switch)
 367           0x15, 0x00,  //       LOGICAL_MINIMUM (0)
 368           0x25, 0x01,  //       LOGICAL_MAXIMUM (1)
 369           0x75, 0x01,  //       REPORT_SIZE (1)
 370           0x95, 0x01,  //       REPORT_COUNT (1)
 371           0x81, 0x02,  //       INPUT (Data,Var,Abs)
 372           0x09, 0x32,  //       USAGE (In Range)
 373           0x81, 0x02,  //       INPUT (Data,Var,Abs)
 374           0x09, 0x47,  //       USAGE (Touch Valid)
 375           0x81, 0x02,  //       INPUT (Data,Var,Abs)
 376           0x95, 0x05,  //       REPORT_COUNT (5)
 377           0x81, 0x03,  //       INPUT (Cnst,Ary,Abs)
 378           0x25, MAX_TOUCH_POINT,  // LOGICAL_MAXIMUM (MAX_TOUCH_POINT)
 379           0x75, 0x08,  //       REPORT_SIZE (8)
 380           0x09, 0x51,  //       USAGE ( Contact Identifier)
 381           0x95, 0x01,  //       REPORT_COUNT (1)
 382           0x81, 0x02,  //       INPUT (Data,Var,Abs)
 383           0x05, 0x01,  //       USAGE_PAGE (Generic Desk..
 384           0x26, 0x00, 0x10,  //       LOGICAL_MAXIMUM (4096)
 385           0x75, 0x10,  //       REPORT_SIZE (16)
 386           0x55, 0x00,  //       UNIT_EXPONENT (0)
 387           0x65, 0x00,  //       UNIT (None)
 388           0x09, 0x30,  //       USAGE (X)
 389           0x35, 0x00,  //       PHYSICAL_MINIMUM (0)
 390           0x46, 0x00, 0x00,  //       PHYSICAL_MAXIMUM (0)
 391           0x81, 0x02,  //       INPUT (Data,Var,Abs)
 392           0x09, 0x31,  //       USAGE (Y)
 393           0x46, 0x00, 0x00,  //       PHYSICAL_MAXIMUM (0)
 394           0x81, 0x02,  //       INPUT (Data,Var,Abs)
 395           0xc0,        //    END_COLLECTION
 396           
 397           //这是一个全局条目，选择用途页为Digitizers
 398           0x05, 0x0d,  //    USAGE_PAGE (Digitizers)
 399           
 400           //这是一个局部条目，选择用途为Contact Count，即当前有多少点触摸
 401           0x09, 0x54,  //    USAGE (Contact Count)
 402           
 403           //这是一个全局条目，说明数据域的数量为1个。
 404           0x95, 0x01,  //    REPORT_COUNT (1)
 405           
 406           //这是一个全局条目，说明每个数据域的长度为8个bit。
 407           0x75, 0x08,  //    REPORT_SIZE (8)
 408           
 409           //这是一个全局条目，说明返回的数据的逻辑最小值为0。
 410           0x15, 0x00,  //    LOGICAL_MINIMUM (0)
 411           
 412           //这是一个全局条目，说明返回的数据的逻辑最大值为MAX_TOUCH_POINT。
 413           0x25, MAX_TOUCH_POINT,  //    LOGICAL_MAXIMUM (MAX_TOUCH_POINT)
 414           
 415           //这是一个主条目，说明有1个长度为8bit的数据域用于输入。
 416           //通过前面的描述我们可以知道，这个8bit是用来表示当前有几个点触摸，
 417           //0表示没有触摸，1表示触摸1个点触摸，2表示2个点触摸等等。
 418           0x81, 0x02,  //    INPUT (Data,Var,Abs)
 419           
 420           //这是一个局部条目，选择用途为Contact Count Maximum，
 421           //表示最多支持多少点同时触摸。
 422           0x09, 0x55,  //    USAGE(Contact Count Maximum)
 423           
 424           //这是一个主条目，说明有1个长度为8bit的数据域用于特性报告。
 425           //通过前面的描述我们可以知道，这个8bit是用来表示最多支持几个点触摸。
 426           0xb1, 0x02,  //    FEATURE (Data,Var,Abs)
C51 COMPILER V7.06   USBCORE                                                               02/25/2012 23:05:51 PAGE 8   

 427           
 428           //这是一个主条目，关集合
 429           0xc0,        // END_COLLECTION
 430           /***********************多点触摸描述完毕***************************/
 431           
 432           /*****************以下是配置设备的特性报告描述符*******************/
 433           //这是一个全局条目，选择用途页为Digitizers
 434           0x05, 0x0d,  //    USAGE_PAGE (Digitizers)
 435           
 436           //这是一个局部条目，选择用途为Device Configuration
 437           0x09, 0x0E,  // USAGE (Device Configuration)
 438           
 439           //这是一个主条目，开集合，后面跟的数据0x01表示该集合是一个应用集合。
 440           //它的性质在前面由用途页和用途定义为Digitizers的Device Configuration。
 441           0xa1, 0x01,  // COLLECTION (Application)
 442           
 443           //全局条目，定义特性报告ID为REPORTID_FEATURE(usbcore.h中定义)
 444           0x85, REPORTID_FEATURE,  //   REPORT_ID (Configuration)
 445           
 446           //这是一个局部条目，选择用途为Device Settings
 447           0x09, 0x23,  //   USAGE (Device Settings)
 448           
 449           //这是一个主条目，开集合，后面跟的数据0x02表示该集合是一个逻辑集合。
 450           0xa1, 0x02,  //   COLLECTION (logical)
 451           
 452           //这是一个局部条目，选择用途为Device Mode
 453           0x09, 0x52,  //    USAGE (Device Mode)
 454           
 455           //这是一个局部条目，选择用途为Device Identifier
 456           0x09, 0x53,  //    USAGE (Device Identifier)
 457           
 458           //这是一个全局条目，说明返回的数据的逻辑最小值为0。
 459           0x15, 0x00,  //    LOGICAL_MINIMUM (0)
 460           
 461           //这是一个全局条目，说明返回的数据的逻辑最大值为10。
 462           0x25, 0x0a,  //    LOGICAL_MAXIMUM (10)
 463           
 464           //这是一个全局条目，说明每个数据域的长度为8个bit。
 465           0x75, 0x08,  //    REPORT_SIZE (8)
 466           
 467           //这是一个全局条目，说明数据域的数量为2个。
 468           0x95, 0x02,  //    REPORT_COUNT (2)
 469           
 470           //这是一个主条目，说明有2个长度为8bit的数据域用于特性报告。
 471           //通过前面的描述我们可以知道，这2个8bit分别用来表示Device Mode和
 472           //Device Identifier。
 473           0xb1, 0x02,  //   FEATURE (Data,Var,Abs)
 474           0xc0,        //   END_COLLECTION
 475           0xc0        // END_COLLECTION
 476           /***********************特性报告描述完毕***************************/
 477          };
 478          //通过上面的报告描述符的定义，我们知道总共定义了三个报告。
 479          /////////////////////////////////////////////////////////////////////
 480          //第一个报告为单点触摸的报告，第一字节为报告ID，值为REPORTID_STOUCH。
 481          //第二字节的低3位用来表示按键是否按下的，高5位为常数0，无用。
 482          //第三、四字节表示X轴的绝对坐标，第五、六字节表示Y轴的绝对坐标。
 483          /////////////////////////////////////////////////////////////////////
 484          //第二个报告为多点触摸的报告，第一字节为报告ID，值为REPORTID_MTOUCH。
 485          //第二字节的低3位用来表示第一点状态的，高5位为常数0，无用。
 486          //第三字节表示第一点触摸的ID号。
 487          //第四、五字节表示第一点X轴的绝对坐标，第六、七字节表示第一点Y轴的绝对坐标。
 488          //第八字节的低3位用来表示第二点状态的，高5位为常数0，无用。
C51 COMPILER V7.06   USBCORE                                                               02/25/2012 23:05:51 PAGE 9   

 489          //第九字节表示第二点触摸的ID号。
 490          //第十、十一字节表示第二点X轴的绝对坐标，第十二、十三节表示第二点Y轴的绝对坐标。
 491          //第十四字节表示当前有多少点触摸。
 492          //另外还有一个两字节的特性报告，第一字节为报告ID，值为REPORTID_MTOUCH，
 493          //第二字节为设备支持的最大触摸点数，主机会通过GET_REPORT请求来获取它。
 494          /////////////////////////////////////////////////////////////////////
 495          //第三个报告为特性报告，第一字节为报告ID，值为REPORTID_FEATURE。
 496          //第二字节表示Device Mode，第三字节表示Device Identifier。
 497          /////////////////////////////////////////////////////////////////////
 498          ///////////////////////////报告描述符完毕////////////////////////////
 499          
 500          //最多支持的点数的报告，这里固定为MAX_TOUCH_POINT，
 501          //即最多只能同时支持MAX_TOUCH_POINT点触摸
 502          code uint8 MaxContactCountReport[2] =
 503          {
 504           REPORTID_MTOUCH, //报告ID
 505           MAX_TOUCH_POINT  //最多同时支持MAX_TOUCH_POINT点触摸
 506          };
 507          
 508          //USB配置描述符集合的定义
 509          //配置描述符总长度为9+9+9+7字节
 510          code uint8 ConfigurationDescriptor[9+9+9+7]=
 511          {
 512           /***************配置描述符***********************/
 513           //bLength字段。配置描述符的长度为9字节。
 514           0x09,
 515           
 516           //bDescriptorType字段。配置描述符编号为0x02。
 517           0x02,
 518           
 519           //wTotalLength字段。配置描述符集合的总长度，
 520           //包括配置描述符本身、接口描述符、类描述符、端点描述符等。
 521           sizeof(ConfigurationDescriptor)&0xFF, //低字节
 522           (sizeof(ConfigurationDescriptor)>>8)&0xFF, //高字节
 523           
 524           //bNumInterfaces字段。该配置包含的接口数，只有一个接口。
 525           0x01,
 526           
 527           //bConfiguration字段。该配置的值为1。
 528           0x01,
 529           
 530           //iConfigurationz字段，该配置的字符串索引。这里没有，为0。
 531           0x00,
 532           
 533           //bmAttributes字段，该设备的属性。由于我们的板子是总线供电的，
 534           //并且我们不想实现远程唤醒的功能，所以该字段的值为0x80。
 535           0x80,
 536           
 537           //bMaxPower字段，该设备需要的最大电流量。由于我们的板子
 538           //需要的电流不到100mA，因此我们这里设置为100mA。由于每单位
 539           //电流为2mA，所以这里设置为50(0x32)。
 540           0x32,
 541           
 542           /*******************接口描述符*********************/
 543           //bLength字段。接口描述符的长度为9字节。
 544           0x09,
 545           
 546           //bDescriptorType字段。接口描述符的编号为0x04。
 547           0x04,
 548           
 549           //bInterfaceNumber字段。该接口的编号，第一个接口，编号为0。
 550           0x00,
C51 COMPILER V7.06   USBCORE                                                               02/25/2012 23:05:51 PAGE 10  

 551           
 552           //bAlternateSetting字段。该接口的备用编号，为0。
 553           0x00,
 554           
 555           //bNumEndpoints字段。非0端点的数目。由于USB触摸屏只需要一个
 556           //中断输入端点，因此该值为1。
 557           0x01,
 558           
 559           //bInterfaceClass字段。该接口所使用的类。USB触摸屏是HID类，
 560           //HID类的编码为0x03。
 561           0x03,
 562           
 563           //bInterfaceSubClass字段。该接口所使用的子类。在HID1.1协议中，
 564           //只规定了一种子类：支持BIOS引导启动的子类。
 565           //USB键盘、鼠标属于该子类，子类代码为0x01。
 566           0x00,
 567           
 568           //bInterfaceProtocol字段。如果子类为支持引导启动的子类，
 569           //则协议可选择鼠标和键盘。键盘代码为0x01，鼠标代码为0x02。
 570           0x00,
 571           
 572           //iConfiguration字段。该接口的字符串索引值。这里没有，为0。
 573           0x00,
 574           
 575           /******************HID描述符************************/
 576           //bLength字段。本HID描述符下只有一个下级描述符。所以长度为9字节。
 577           0x09,
 578           
 579           //bDescriptorType字段。HID描述符的编号为0x21。
 580           0x21,
 581           
 582           //bcdHID字段。本协议使用的HID1.1协议。注意低字节在先。
 583           0x10,
 584           0x01,
 585           
 586           //bCountyCode字段。设备适用的国家代码，这里选择为美国，代码0x21。
 587           0x21,
 588           
 589           //bNumDescriptors字段。下级描述符的数目。我们只有一个报告描述符。
 590           0x01,
 591           
 592           //bDescritporType字段。下级描述符的类型，为报告描述符，编号为0x22。
 593           0x22,
 594           
 595           //bDescriptorLength字段。下级描述符的长度。下级描述符为报告描述符。
 596           sizeof(ReportDescriptor)&0xFF,
 597           (sizeof(ReportDescriptor)>>8)&0xFF,
 598           
 599           /**********************端点描述符***********************/
 600           //bLength字段。端点描述符长度为7字节。
 601           0x07,
 602           
 603           //bDescriptorType字段。端点描述符编号为0x05。
 604           0x05,
 605           
 606           //bEndpointAddress字段。端点的地址。我们使用D12的输入端点1。
 607           //D7位表示数据方向，输入端点D7为1。所以输入端点1的地址为0x81。
 608           0x81,
 609           
 610           //bmAttributes字段。D1~D0为端点传输类型选择。
 611           //该端点为中断端点。中断端点的编号为3。其它位保留为0。
 612           0x03,
C51 COMPILER V7.06   USBCORE                                                               02/25/2012 23:05:51 PAGE 11  

 613           
 614           //wMaxPacketSize字段。该端点的最大包长。端点1的最大包长为16字节。
 615           //注意低字节在先。
 616           0x10,
 617           0x00,
 618           
 619           //bInterval字段。端点查询的时间，我们设置为10个帧时间，即10ms。
 620           0x0a
 621          };
 622          ////////////////////////配置描述符集合完毕//////////////////////////
 623          
 624          /************************语言ID的定义********************/
 625          code uint8 LanguageId[4]=
 626          {
 627           0x04, //本描述符的长度
 628           0x03, //字符串描述符
 629           //0x0409为美式英语的ID
 630           0x09,
 631           0x04
 632          };
 633          ////////////////////////语言ID完毕//////////////////////////////////
 634          
 635          /**************************************************/
 636          /*********        本转换结果来自         **********/
 637          /********* Http://computer00.21ic.org    **********/
 638          /*********        作者: 电脑圈圈         **********/
 639          /*********         欢迎大家使用          **********/
 640          /*********    版权所有，盗版请写明出处   **********/
 641          /**************************************************/
 642          
 643          //http://computer00.21ic.org/user1/2198/archives/2007/42769.html
 644          //字符串“电脑圈圈的USB专区 Http://group.ednchina.com/93/”的Unicode编码
 645          //8位小端格式
 646          code uint8 ManufacturerStringDescriptor[82]={
 647          82,         //该描述符的长度为82字节
 648          0x03,       //字符串描述符的类型编码为0x03
 649          0x35, 0x75, //电
 650          0x11, 0x81, //脑
 651          0x08, 0x57, //圈
 652          0x08, 0x57, //圈
 653          0x84, 0x76, //的
 654          0x55, 0x00, //U
 655          0x53, 0x00, //S
 656          0x42, 0x00, //B
 657          0x13, 0x4e, //专
 658          0x3a, 0x53, //区
 659          0x20, 0x00, // 
 660          0x48, 0x00, //H
 661          0x74, 0x00, //t
 662          0x74, 0x00, //t
 663          0x70, 0x00, //p
 664          0x3a, 0x00, //:
 665          0x2f, 0x00, ///
 666          0x2f, 0x00, ///
 667          0x67, 0x00, //g
 668          0x72, 0x00, //r
 669          0x6f, 0x00, //o
 670          0x75, 0x00, //u
 671          0x70, 0x00, //p
 672          0x2e, 0x00, //.
 673          0x65, 0x00, //e
 674          0x64, 0x00, //d
C51 COMPILER V7.06   USBCORE                                                               02/25/2012 23:05:51 PAGE 12  

 675          0x6e, 0x00, //n
 676          0x63, 0x00, //c
 677          0x68, 0x00, //h
 678          0x69, 0x00, //i
 679          0x6e, 0x00, //n
 680          0x61, 0x00, //a
 681          0x2e, 0x00, //.
 682          0x63, 0x00, //c
 683          0x6f, 0x00, //o
 684          0x6d, 0x00, //m
 685          0x2f, 0x00, ///
 686          0x39, 0x00, //9
 687          0x33, 0x00, //3
 688          0x2f, 0x00  ///
 689          };
 690          /////////////////////////厂商字符串结束/////////////////////////////
 691          
 692          //字符串“《圈圈教你玩USB》之USB多点触摸屏设备”的Unicode编码
 693          //8位小端格式
 694          code uint8 ProductStringDescriptor[44]={
 695          44,         //该描述符的长度为44字节
 696          0x03,       //字符串描述符的类型编码为0x03
 697          0x0a, 0x30, //《
 698          0x08, 0x57, //圈
 699          0x08, 0x57, //圈
 700          0x59, 0x65, //教
 701          0x60, 0x4f, //你
 702          0xa9, 0x73, //玩
 703          0x55, 0x00, //U
 704          0x53, 0x00, //S
 705          0x42, 0x00, //B
 706          0x0b, 0x30, //》
 707          0x4b, 0x4e, //之
 708          0x55, 0x00, //U
 709          0x53, 0x00, //S
 710          0x42, 0x00, //B
 711          0x1a, 0x59, //多
 712          0xb9, 0x70, //点
 713          0xe6, 0x89, //触
 714          0x78, 0x64, //摸
 715          0x4f, 0x5c, //屏
 716          0xbe, 0x8b, //设
 717          0x07, 0x59  //备
 718          };
 719          ////////////////////////产品字符串结束////////////////////////////
 720          
 721          //字符串“2012-01-25”的Unicode编码
 722          //8位小端格式
 723          code uint8 SerialNumberStringDescriptor[22]={
 724          22,         //该描述符的长度为22字节
 725          0x03,       //字符串描述符的类型编码为0x03
 726          0x32, 0x00, //2
 727          0x30, 0x00, //0
 728          0x31, 0x00, //1
 729          0x32, 0x00, //2
 730          0x2d, 0x00, //-
 731          0x30, 0x00, //0
 732          0x31, 0x00, //1
 733          0x2d, 0x00, //-
 734          0x32, 0x00, //2
 735          0x35, 0x00  //5
 736          };
C51 COMPILER V7.06   USBCORE                                                               02/25/2012 23:05:51 PAGE 13  

 737          //////////////////////产品序列号字符串结束/////////////////////////
 738          
 739          /********************************************************************
 740          函数功能：延时x毫秒函数。
 741          入口参数：x：延时的毫秒数。
 742          返    回：无。
 743          备    注：无。
 744          ********************************************************************/
 745          void DelayXms(uint16 x)                
 746          {
 747   1       uint16 i;
 748   1       uint16 j;
 749   1       for(i=0;i<x;i++)
 750   1       for(j=0;j<227;j++); //循环语句延时
 751   1      }
 752          ////////////////////////End of function//////////////////////////////
 753          
 754          /********************************************************************
 755          函数功能：USB断开连接函数。
 756          入口参数：无。
 757          返    回：无。
 758          备    注：无。
 759          ********************************************************************/
 760          void UsbDisconnect(void)
 761          {
 762   1      #ifdef DEBUG0
               Prints("断开USB连接。\r\n");
              #endif
 765   1       D12WriteCommand(D12_SET_MODE);  //写设置模式命令
 766   1       D12WriteByte(0x06); //设置模式的第一字节
 767   1       D12WriteByte(0x47); //设置模式的第二字节
 768   1       DelayXms(1000);  //延迟1秒
 769   1      }
 770          ////////////////////////End of function//////////////////////////////
 771          
 772          /********************************************************************
 773          函数功能：USB连接函数。
 774          入口参数：无。
 775          返    回：无。
 776          备    注：无。
 777          ********************************************************************/
 778          void UsbConnect(void)
 779          {
 780   1      #ifdef DEBUG0
               Prints("连接USB。\r\n");
              #endif
 783   1       D12WriteCommand(D12_SET_MODE);  //写设置模式命令
 784   1       D12WriteByte(0x16); //设置模式的第一字节
 785   1       D12WriteByte(0x47); //设置模式的第二字节
 786   1      }
 787          ////////////////////////End of function//////////////////////////////
 788          
 789          /********************************************************************
 790          函数功能：总线挂起中断处理函数。
 791          入口参数：无。
 792          返    回：无。
 793          备    注：无。
 794          ********************************************************************/
 795          void UsbBusSuspend(void)
 796          {
 797   1      #ifdef DEBUG0
               Prints("USB总线挂起。\r\n");
C51 COMPILER V7.06   USBCORE                                                               02/25/2012 23:05:51 PAGE 14  

              #endif
 800   1      }
 801          ////////////////////////End of function//////////////////////////////
 802          
 803          /********************************************************************
 804          函数功能：总线复位中断处理函数。
 805          入口参数：无。
 806          返    回：无。
 807          备    注：无。
 808          ********************************************************************/
 809          void UsbBusReset(void)
 810          {
 811   1      #ifdef DEBUG0
               Prints("USB总线复位。\r\n");
              #endif
 814   1       Ep1InIsBusy=0; //复位后端点1输入缓冲区空闲。
 815   1       TouchMode = MOUSE_MODE; //默认为鼠标模式
 816   1      }
 817          ////////////////////////End of function//////////////////////////////
 818          
 819          /********************************************************************
 820          函数功能：根据pData和SendLength将数据发送到端点0的函数。
 821          入口参数：无。
 822          返    回：无。
 823          备    注：无。
 824          ********************************************************************/
 825          void UsbEp0SendData(void)
 826          {
 827   1       //将数据写到端点中去准备发送
 828   1       //写之前要先判断一下需要发送的数据是否比端点0
 829   1       //最大长度大，如果超过端点大小，则一次只能发送
 830   1       //最大包长的数据。端点0的最大包长在DeviceDescriptor[7]
 831   1       if(SendLength>DeviceDescriptor[7])
 832   1       {
 833   2        //按最大包长度发送
 834   2        D12WriteEndpointBuffer(1,DeviceDescriptor[7],pSendData);
 835   2        //发送后剩余字节数减少最大包长
 836   2        SendLength-=DeviceDescriptor[7];
 837   2        //发送一次后指针位置要调整
 838   2        pSendData+= DeviceDescriptor[7];
 839   2       }
 840   1       else
 841   1       {
 842   2        if(SendLength!=0)
 843   2        {
 844   3         //不够最大包长，可以直接发送
 845   3         D12WriteEndpointBuffer(1,SendLength,pSendData);
 846   3         //发送完毕后，SendLength长度变为0
 847   3         SendLength=0;
 848   3        }
 849   2        else //如果要发送的数据包长度为0
 850   2        {
 851   3         if(NeedZeroPacket==1) //如果需要发送0长度数据
 852   3         {
 853   4          D12WriteEndpointBuffer(1,0,pSendData); //发送0长度数据包
 854   4          NeedZeroPacket=0; //清需要发送0长度数据包标志
 855   4         }
 856   3        }
 857   2       }
 858   1      }
 859          ////////////////////////End of function//////////////////////////////
 860          
C51 COMPILER V7.06   USBCORE                                                               02/25/2012 23:05:51 PAGE 15  

 861          uint8 TouchMode = MOUSE_MODE; //默认为鼠标模式
 862          /********************************************************************
 863          函数功能：USB端点0数据过程数据处理函数。
 864          入口参数：无。
 865          返    回：无。
 866          备    注：该函数用来处理0端点控制传输的数据或状态过程。
 867          ********************************************************************/
 868          void UsbEp0DataOut(void)
 869          {
 870   1       //由于本程序中只有一个请求输出数据，所以可以直接使用if语句判断条件，
 871   1       //如果有很多请求的话，使用if语句就不方便了，而应该使用switch语句散转。
 872   1       if((bmRequestType == 0x21) && //是类请求
 873   1          (bRequest == SET_REPORT) && //且请求类型是SET_REPORT
 874   1          ((wValue & 0xFF00) == (0x03 << 8)) && //且报告类型为3(Feature)
 875   1           ((wValue & 0xFF) == REPORTID_FEATURE) && //且报告ID为REPORTID_FEATURE
 876   1           (wIndex == 0) && (wLength == 3)) //且wIndex为0且wLength为3
 877   1       {
 878   2        uint8 ReportBuf[3];
 879   2        uint8 Length;
 880   2        //读回端点0中的数据
 881   2        Length=D12ReadEndpointBuffer(0,3,ReportBuf);
 882   2        D12ClearBuffer(); //清除缓冲区
 883   2        #ifdef DEBUG0
                 Prints("设置特性报告(Device Mode和Device Identifier).\r\n");
                #endif
 886   2        
 887   2        if(Length == wLength) //如果读取数据的长度正确
 888   2        {
 889   3         if(ReportBuf[0] == REPORTID_FEATURE) //报告ID正确
 890   3         {
 891   4          TouchMode = ReportBuf[1];
 892   4          switch(TouchMode)
 893   4          {
 894   5           case MOUSE_MODE:
 895   5           #ifdef DEBUG0
                    Prints("鼠标模式.\r\n");
                   #endif
 898   5           break;
 899   5           
 900   5           case SINGLE_TOUCH_MODE:
 901   5           #ifdef DEBUG0
                    Prints("单点触摸模式.\r\n");
                   #endif
 904   5           break;
 905   5           
 906   5           case MULTI_TOUCH_MODE:
 907   5           #ifdef DEBUG0
                    Prints("多点触摸模式.\r\n");
                   #endif
 910   5           break;
 911   5           
 912   5           default:
 913   5           #ifdef DEBUG0
                    Prints("未知模式.\r\n");
                   #endif
 916   5           break;
 917   5          }
 918   4         }
 919   3        }
 920   2        //返回0长度的状态数据包。
 921   2        D12WriteEndpointBuffer(1,0,0);
 922   2       }
C51 COMPILER V7.06   USBCORE                                                               02/25/2012 23:05:51 PAGE 16  

 923   1       else  //其它请求的数据过程或者状态过程
 924   1       {
 925   2        D12ReadEndpointBuffer(0,16,Buffer);
 926   2        D12ClearBuffer();
 927   2       }
 928   1      }
 929          ////////////////////////End of function//////////////////////////////
 930          
 931          /********************************************************************
 932          函数功能：端点0输出中断处理函数。
 933          入口参数：无。
 934          返    回：无。
 935          备    注：无。
 936          ********************************************************************/
 937          void UsbEp0Out(void)
 938          {
 939   1      #ifdef DEBUG0
               Prints("USB端点0输出中断。\r\n");
              #endif
 942   1       //读取端点0输出最后传输状态，该操作清除中断标志
 943   1       //并判断第5位是否为1，如果是，则说明是建立包
 944   1       if(D12ReadEndpointLastStatus(0)&0x20)
 945   1       {
 946   2        D12ReadEndpointBuffer(0,16,Buffer); //读建立过程数据
 947   2        D12AcknowledgeSetup(); //应答建立包
 948   2        D12ClearBuffer(); //清缓冲区
 949   2        //将缓冲数据填到设备请求的各字段中
 950   2        bmRequestType=Buffer[0];
 951   2        bRequest=Buffer[1];
 952   2        wValue=Buffer[2]+(((uint16)Buffer[3])<<8);
 953   2        wIndex=Buffer[4]+(((uint16)Buffer[5])<<8);
 954   2        wLength=Buffer[6]+(((uint16)Buffer[7])<<8);
 955   2        //下面的代码判断具体的请求，并根据不同的请求进行相关操作
 956   2        //如果D7位为1，则说明是输入请求
 957   2        if((bmRequestType&0x80)==0x80)
 958   2        {
 959   3         //根据bmRequestType的D6~5位散转，D6~5位表示请求的类型
 960   3         //0为标准请求，1为类请求，2为厂商请求。
 961   3         switch((bmRequestType>>5)&0x03)
 962   3         {
 963   4          case 0:  //标准请求
 964   4           #ifdef DEBUG0
                    Prints("USB标准输入请求：");
                   #endif
 967   4           //USB协议定义了几个标准输入请求，我们实现这些标准请求即可
 968   4           //请求的代码在bRequest中，对不同的请求代码进行散转
 969   4           //事实上，我们还需要对接收者进行散转，因为不同的请求接收者
 970   4           //是不一样的。接收者在bmRequestType的D4~D0位中定义。
 971   4           //我们这里为了简化操作，有些就省略了对接收者的判断。
 972   4           //例如获取描述符的请求，只根据描述符的类型来区别。
 973   4           switch(bRequest)
 974   4           {
 975   5            case GET_CONFIGURATION: //获取配置
 976   5             #ifdef DEBUG0
                      Prints("获取配置。\r\n");
                     #endif
 979   5            break;
 980   5            
 981   5            case GET_DESCRIPTOR:  //获取描述符
 982   5             #ifdef DEBUG0
                      Prints("获取描述符――");
                     #endif
C51 COMPILER V7.06   USBCORE                                                               02/25/2012 23:05:51 PAGE 17  

 985   5             //对描述符类型进行散转，对于全速设备，
 986   5             //标准请求只支持发送到设备的设备、配置、字符串三种描述符
 987   5             switch((wValue>>8)&0xFF)
 988   5              {
 989   6               case DEVICE_DESCRIPTOR: //设备描述符
 990   6                #ifdef DEBUG0
                         Prints("设备描述符。\r\n");
                        #endif
 993   6                pSendData=DeviceDescriptor;  //需要发送的数据
 994   6                //判断请求的字节数是否比实际需要发送的字节数多
 995   6                //这里请求的是设备描述符，因此数据长度就是
 996   6                //DeviceDescriptor[0]。如果请求的比实际的长，
 997   6                //那么只返回实际长度的数据
 998   6                if(wLength>DeviceDescriptor[0])
 999   6                {
1000   7                 SendLength=DeviceDescriptor[0];
1001   7                 if(SendLength%DeviceDescriptor[7]==0) //并且刚好是整数个数据包时
1002   7                 {
1003   8                  NeedZeroPacket=1; //需要返回0长度的数据包
1004   8                 }
1005   7                }
1006   6                else
1007   6                {
1008   7                 SendLength=wLength;
1009   7                }
1010   6                //将数据通过EP0返回
1011   6                UsbEp0SendData();
1012   6               break;
1013   6               
1014   6               case CONFIGURATION_DESCRIPTOR:  //配置描述符
1015   6                #ifdef DEBUG0
                         Prints("配置描述符。\r\n");
                        #endif
1018   6                pSendData=ConfigurationDescriptor; //需要发送的数据为配置描述符
1019   6                //判断请求的字节数是否比实际需要发送的字节数多
1020   6                //这里请求的是配置描述符集合，因此数据长度就是
1021   6                //ConfigurationDescriptor[3]*256+ConfigurationDescriptor[2]。
1022   6                //如果请求的比实际的长，那么只返回实际长度的数据
1023   6                SendLength=ConfigurationDescriptor[3];
1024   6                SendLength=SendLength*256+ConfigurationDescriptor[2];
1025   6                if(wLength>SendLength)
1026   6                {
1027   7                 if(SendLength%DeviceDescriptor[7]==0) //并且刚好是整数个数据包时
1028   7                 {
1029   8                  NeedZeroPacket=1; //需要返回0长度的数据包
1030   8                 }
1031   7                }
1032   6                else
1033   6                {
1034   7                 SendLength=wLength;
1035   7                }
1036   6                //将数据通过EP0返回
1037   6                UsbEp0SendData();
1038   6               break;
1039   6               
1040   6               case STRING_DESCRIPTOR:  //字符串描述符
1041   6                #ifdef DEBUG0
                         Prints("字符串描述符");
                        #endif
1044   6                switch(wValue&0xFF)  //根据wValue的低字节（索引值）散转
1045   6                {
1046   7                 case 0:  //获取语言ID
C51 COMPILER V7.06   USBCORE                                                               02/25/2012 23:05:51 PAGE 18  

1047   7                  #ifdef DEBUG0
                           Prints("(语言ID)。\r\n");
                          #endif
1050   7                  pSendData=LanguageId;
1051   7                  SendLength=LanguageId[0];
1052   7                 break;
1053   7                 
1054   7                 case 1:  //厂商字符串的索引值为1，所以这里为厂商字符串
1055   7                 #ifdef DEBUG0
                           Prints("(厂商描述)。\r\n");
                          #endif
1058   7                  pSendData=ManufacturerStringDescriptor;
1059   7                  SendLength=ManufacturerStringDescriptor[0];
1060   7                 break;
1061   7                 
1062   7                 case 2:  //产品字符串的索引值为2，所以这里为产品字符串
1063   7                 #ifdef DEBUG0
                           Prints("(产品描述)。\r\n");
                          #endif
1066   7                  pSendData=ProductStringDescriptor;
1067   7                  SendLength=ProductStringDescriptor[0];
1068   7                 break;
1069   7                 
1070   7                 case 3:  //产品序列号的索引值为3，所以这里为序列号
1071   7                 #ifdef DEBUG0
                           Prints("(产品序列号)。\r\n");
                          #endif
1074   7                  pSendData=SerialNumberStringDescriptor;
1075   7                  SendLength=SerialNumberStringDescriptor[0];
1076   7                 break;
1077   7                 
1078   7                 default :
1079   7                  #ifdef DEBUG0
                           Prints("(未知的索引值)。\r\n");
                          #endif
1082   7                  //对于未知索引值的请求，返回一个0长度的包
1083   7                  SendLength=0;
1084   7                  NeedZeroPacket=1;
1085   7                 break;
1086   7                }
1087   6                //判断请求的字节数是否比实际需要发送的字节数多
1088   6                //如果请求的比实际的长，那么只返回实际长度的数据
1089   6                if(wLength>SendLength)
1090   6                {
1091   7                 if(SendLength%DeviceDescriptor[7]==0) //并且刚好是整数个数据包时
1092   7                 {
1093   8                  NeedZeroPacket=1; //需要返回0长度的数据包
1094   8                 }
1095   7                }
1096   6                else
1097   6                {
1098   7                 SendLength=wLength;
1099   7                }
1100   6                //将数据通过EP0返回
1101   6                UsbEp0SendData();         
1102   6               break;
1103   6      
1104   6               case REPORT_DESCRIPTOR:  //报告描述符
1105   6                #ifdef DEBUG0
                         Prints("报告描述符。\r\n");
                        #endif
1108   6                pSendData=ReportDescriptor; //需要发送的数据为报告描述符
C51 COMPILER V7.06   USBCORE                                                               02/25/2012 23:05:51 PAGE 19  

1109   6                SendLength=sizeof(ReportDescriptor); //需要返回的数据长度         
1110   6                //判断请求的字节数是否比实际需要发送的字节数多
1111   6                //如果请求的比实际的长，那么只返回实际长度的数据
1112   6                if(wLength>SendLength)
1113   6                {
1114   7                 if(SendLength%DeviceDescriptor[7]==0) //并且刚好是整数个数据包时
1115   7                 {
1116   8                  NeedZeroPacket=1; //需要返回0长度的数据包
1117   8                 }
1118   7                }
1119   6                else
1120   6                {
1121   7                 SendLength=wLength;
1122   7                }
1123   6                //将数据通过EP0返回
1124   6                UsbEp0SendData();
1125   6               break;
1126   6                       
1127   6               default:  //其它描述符
1128   6                #ifdef DEBUG0
                         Prints("其他描述符，描述符代码：");
                         PrintHex((wValue>>8)&0xFF);
                         Prints("\r\n");
                        #endif
1133   6               break;
1134   6              }
1135   5             break;
1136   5            
1137   5            case GET_INTERFACE: //获取接口
1138   5             #ifdef DEBUG0
                      Prints("获取接口。\r\n");
                     #endif
1141   5            break;
1142   5            
1143   5            case GET_STATUS: //获取状态
1144   5             #ifdef DEBUG0
                      Prints("获取状态。\r\n");
                     #endif
1147   5            break;
1148   5            
1149   5            case SYNCH_FRAME: //同步帧
1150   5             #ifdef DEBUG0
                      Prints("同步帧。\r\n");
                     #endif
1153   5            break;
1154   5            
1155   5            default:  //未定义的标准请求
1156   5             #ifdef DEBUG0
                      Prints("错误：未定义的标准输入请求。\r\n");
                     #endif       
1159   5            break;
1160   5           }
1161   4          break;
1162   4          
1163   4          case 1:  //类请求
1164   4           #ifdef DEBUG0
                    Prints("USB类输入请求：\r\n");
                   #endif
1167   4           switch(bRequest)
1168   4           {
1169   5            case GET_REPORT:
1170   5            #ifdef DEBUG0
C51 COMPILER V7.06   USBCORE                                                               02/25/2012 23:05:51 PAGE 20  

                     Prints("获取报告......\r\n");
                    #endif
1173   5            //报告类型为3(Feature)且报告ID为REPORTID_MTOUCH
1174   5            if(wValue == ((0x03 << 8) | REPORTID_MTOUCH))
1175   5            {
1176   6             if((wIndex == 0) && (wLength == 2)) //wIndex为0且wLength为2
1177   6             {
1178   7              //通过端点0返回我们的特性报告，这个特性报告就是我们在多点触摸
1179   7              //报告描述符中，最后描述的那个Contact Count Maximum，即系统要
1180   7              //获取能够支持最大的触摸点数，我们这里返回一个固定的值。
1181   7              //之所以这里请求的是2字节，是因为有一字节的报告ID。
1182   7              pSendData=MaxContactCountReport; //需要发送的数据
1183   7              SendLength=wLength; //需要返回的数据长度
1184   7              //将数据通过EP0返回
1185   7              UsbEp0SendData();
1186   7             }
1187   6            }
1188   5            break;
1189   5            
1190   5            default:
1191   5            #ifdef DEBUG0
                     Prints("未知USB类输入请求。\r\n");
                    #endif
1194   5            break;
1195   5           }
1196   4          break;
1197   4          
1198   4          case 2:  //厂商请求
1199   4           #ifdef DEBUG0
                    Prints("USB厂商输入请求：\r\n");
                   #endif
1202   4          break;
1203   4          
1204   4          default: //未定义的请求。这里只显示一个报错信息。
1205   4           #ifdef DEBUG0
                    Prints("错误：未定义的输入请求。\r\n");
                   #endif
1208   4          break;
1209   4         }
1210   3        }
1211   2        //否则说明是输出请求
1212   2        else //if(bmRequestType&0x80==0x80)之else
1213   2        {
1214   3         //根据bmRequestType的D6~5位散转，D6~5位表示请求的类型
1215   3         //0为标准请求，1为类请求，2为厂商请求。
1216   3         switch((bmRequestType>>5)&0x03)
1217   3         {
1218   4          case 0:  //标准请求
1219   4           #ifdef DEBUG0
                    Prints("USB标准输出请求：");
                   #endif
1222   4           //USB协议定义了几个标准输出请求，我们实现这些标准请求即可
1223   4           //请求的代码在bRequest中，对不同的请求代码进行散转
1224   4           switch(bRequest)
1225   4           {
1226   5            case CLEAR_FEATURE: //清除特性
1227   5             #ifdef DEBUG0
                      Prints("清除特性。\r\n");
                     #endif
1230   5            break;
1231   5            
1232   5            case SET_ADDRESS:  //设置地址
C51 COMPILER V7.06   USBCORE                                                               02/25/2012 23:05:51 PAGE 21  

1233   5             #ifdef DEBUG0
                      Prints("设置地址。地址为：");
                      PrintHex(wValue&0xFF); //显示所设置的地址
                      Prints("\r\n");
                     #endif
1238   5             D12SetAddress(wValue&0xFF); //wValue中的低字节是设置的地址值
1239   5             //设置地址没有数据过程，直接进入到状态过程，返回一个0长度的数据包
1240   5             SendLength=0;
1241   5             NeedZeroPacket=1;
1242   5             //将数据通过EP0返回
1243   5             UsbEp0SendData();
1244   5            break;
1245   5            
1246   5            case SET_CONFIGURATION: //设置配置
1247   5             #ifdef DEBUG0
                      Prints("设置配置。\r\n");
                     #endif
1250   5             //使能非0端点。非0端点只有在设置为非0的配置后才能使能。
1251   5             //wValue的低字节为配置的值，如果该值为非0，才能使能非0端点。
1252   5             //保存当前配置值
1253   5             ConfigValue=wValue&0xFF;
1254   5             D12SetEndpointEnable(ConfigValue);
1255   5             //返回一个0长度的状态数据包
1256   5             SendLength=0;
1257   5             NeedZeroPacket=1;
1258   5             //将数据通过EP0返回
1259   5             UsbEp0SendData();
1260   5            break;
1261   5            
1262   5            case SET_DESCRIPTOR: //设置描述符
1263   5             #ifdef DEBUG0
                      Prints("设置描述符。\r\n");
                     #endif
1266   5            break;
1267   5            
1268   5            case SET_FEATURE: //设置特性
1269   5             #ifdef DEBUG0
                      Prints("设置特性。\r\n");
                     #endif
1272   5            break;
1273   5      
1274   5            case SET_INTERFACE: //设置接口
1275   5             #ifdef DEBUG0
                      Prints("设置接口。\r\n");
                     #endif
1278   5            break;      
1279   5            
1280   5            default:  //未定义的标准请求
1281   5             #ifdef DEBUG0
                      Prints("错误：未定义的标准输出请求。\r\n");
                     #endif       
1284   5            break;
1285   5           }
1286   4          break;
1287   4          
1288   4          case 1:  //类请求
1289   4           #ifdef DEBUG0
                    Prints("USB类输出请求：");
                   #endif
1292   4           switch(bRequest)
1293   4           {
1294   5            case SET_IDLE:
C51 COMPILER V7.06   USBCORE                                                               02/25/2012 23:05:51 PAGE 22  

1295   5             #ifdef DEBUG0
                      Prints("设置空闲。\r\n");
                     #endif
1298   5             //只需要返回一个0长度的数据包即可
1299   5             SendLength=0;
1300   5             NeedZeroPacket=1;
1301   5             //将数据通过EP0返回
1302   5             UsbEp0SendData();
1303   5            break;
1304   5            
1305   5            case SET_REPORT:
1306   5             #ifdef DEBUG0
                      Prints("设置报告。\r\n");
                     #endif
1309   5             //该请求为设置报告，但是实际的数据并不在设置过程发出，
1310   5             //而是在之后的数据过程发出。这里不用做任何处理，在数据过程
1311   5             //完成后返回0长度的状态包。
1312   5            break;
1313   5            
1314   5            default:
1315   5             #ifdef DEBUG0
                      Prints("未知请求。\r\n");
                     #endif
1318   5            break;
1319   5           }
1320   4          break;
1321   4          
1322   4          case 2:  //厂商请求
1323   4           #ifdef DEBUG0
                    Prints("USB厂商输出请求：\r\n");
                   #endif
1326   4          break;
1327   4          
1328   4          default: //未定义的请求。这里只显示一个报错信息。
1329   4           #ifdef DEBUG0
                    Prints("错误：未定义的输出请求。\r\n");
                   #endif
1332   4          break;
1333   4         }
1334   3        }
1335   2       }
1336   1       //普通数据输出
1337   1       else //if(D12ReadEndpointLastStatus(0)&0x20)之else
1338   1       {
1339   2        UsbEp0DataOut();
1340   2       }
1341   1      }
1342          ////////////////////////End of function//////////////////////////////
1343          
1344          /********************************************************************
1345          函数功能：端点0输入中断处理函数。
1346          入口参数：无。
1347          返    回：无。
1348          备    注：无。
1349          ********************************************************************/
1350          void UsbEp0In(void)
1351          {
1352   1      #ifdef DEBUG0
               Prints("USB端点0输入中断。\r\n");
              #endif
1355   1       //读最后发送状态，这将清除端点0的中断标志位
1356   1       D12ReadEndpointLastStatus(1);
C51 COMPILER V7.06   USBCORE                                                               02/25/2012 23:05:51 PAGE 23  

1357   1       //发送剩余的字节数
1358   1       UsbEp0SendData();
1359   1      }
1360          ////////////////////////End of function//////////////////////////////
1361          
1362          /********************************************************************
1363          函数功能：端点1输出中断处理函数。
1364          入口参数：无。
1365          返    回：无。
1366          备    注：无。
1367          ********************************************************************/
1368          void UsbEp1Out(void)
1369          {
1370   1      #ifdef DEBUG0
               Prints("USB端点1输出中断。\r\n");
              #endif
1373   1      }
1374          ////////////////////////End of function//////////////////////////////
1375          
1376          /********************************************************************
1377          函数功能：端点1输入中断处理函数。
1378          入口参数：无。
1379          返    回：无。
1380          备    注：无。
1381          ********************************************************************/
1382          void UsbEp1In(void)
1383          {
1384   1      #ifdef DEBUG0
               Prints("USB端点1输入中断。\r\n");
              #endif
1387   1       //读最后发送状态，这将清除端点1输入的中断标志位
1388   1       D12ReadEndpointLastStatus(3);
1389   1       //端点1输入处于空闲状态
1390   1       Ep1InIsBusy=0;
1391   1      }
1392          ////////////////////////End of function//////////////////////////////
1393          
1394          /********************************************************************
1395          函数功能：端点2输出中断处理函数。
1396          入口参数：无。
1397          返    回：无。
1398          备    注：无。
1399          ********************************************************************/
1400          void UsbEp2Out(void)
1401          {
1402   1      #ifdef DEBUG0
               Prints("USB端点2输出中断。\r\n");
              #endif
1405   1      }
1406          ////////////////////////End of function//////////////////////////////
1407          
1408          /********************************************************************
1409          函数功能：端点2输入中断处理函数。
1410          入口参数：无。
1411          返    回：无。
1412          备    注：无。
1413          ********************************************************************/
1414          void UsbEp2In(void)
1415          {
1416   1      #ifdef DEBUG0
               Prints("USB端点2输入中断。\r\n");
              #endif
C51 COMPILER V7.06   USBCORE                                                               02/25/2012 23:05:51 PAGE 24  

1419   1      }
1420          ////////////////////////End of function//////////////////////////////


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    905    ----
   CONSTANT SIZE    =    451    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     17       4
   IDATA SIZE       =     16    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
